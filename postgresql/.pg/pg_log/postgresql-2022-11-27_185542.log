2022-11-27 18:55:42.022 UTC [11909] LOG:  starting PostgreSQL 14.5 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 11.3.0, 64-bit
2022-11-27 18:55:42.023 UTC [11909] LOG:  listening on IPv6 address "::1", port 5555
2022-11-27 18:55:42.023 UTC [11909] LOG:  listening on IPv4 address "127.0.0.1", port 5555
2022-11-27 18:55:42.030 UTC [11909] LOG:  listening on Unix socket "/home/edgar/code/Polytech_SI3_S5/postgresql/.pg/.s.PGSQL.5555"
2022-11-27 18:55:42.036 UTC [11911] LOG:  database system was shut down at 2022-11-26 18:38:51 UTC
2022-11-27 18:55:42.041 UTC [11909] LOG:  database system is ready to accept connections
2022-11-27 18:57:23.515 UTC [12445] LOG:  connection received: host=::1 port=50114
2022-11-27 18:57:23.523 UTC [12445] LOG:  connection authorized: user=postgres database=postgres application_name=pgAdmin 4 - DB:postgres
2022-11-27 18:57:23.526 UTC [12445] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='UNICODE';
2022-11-27 18:57:23.543 UTC [12445] LOG:  duration: 17.775 ms
2022-11-27 18:57:23.544 UTC [12445] LOG:  statement: SELECT version()
2022-11-27 18:57:23.544 UTC [12445] LOG:  duration: 0.225 ms
2022-11-27 18:57:23.544 UTC [12445] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2022-11-27 18:57:23.549 UTC [12445] LOG:  duration: 5.268 ms
2022-11-27 18:57:23.550 UTC [12445] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2022-11-27 18:57:23.552 UTC [12445] LOG:  duration: 2.253 ms
2022-11-27 18:57:23.553 UTC [12445] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2022-11-27 18:57:23.560 UTC [12445] LOG:  duration: 7.420 ms
2022-11-27 18:57:23.595 UTC [12445] LOG:  statement: SELECT CASE WHEN usesuper
	       THEN pg_catalog.pg_is_in_recovery()
	       ELSE FALSE
	       END as inrecovery,
	       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
	       THEN pg_is_wal_replay_paused()
	       ELSE FALSE
	       END as isreplaypaused
	FROM pg_catalog.pg_user WHERE usename=current_user
2022-11-27 18:57:23.596 UTC [12445] LOG:  duration: 1.098 ms
2022-11-27 18:57:23.898 UTC [12445] LOG:  statement: 
	SELECT
	    has_table_privilege(
	      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
	    ) has_priviledge
	WHERE EXISTS(
	    SELECT has_schema_privilege('pgagent', 'USAGE')
	    WHERE EXISTS(
	        SELECT cl.oid FROM pg_catalog.pg_class cl
	        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
	        WHERE relname='pga_job' AND nspname='pgagent'
	    )
	)
	
2022-11-27 18:57:23.917 UTC [12445] LOG:  duration: 18.697 ms
2022-11-27 18:57:27.425 UTC [12445] LOG:  statement: SELECT
	    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
	    db.datistemplate AS is_template,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner
	FROM
	    pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
	WHERE         db.oid > 16383::OID OR db.datname IN ('postgres', 'edb')
	
	ORDER BY datname;
2022-11-27 18:57:27.431 UTC [12445] LOG:  duration: 6.630 ms
2022-11-27 18:57:33.958 UTC [12481] LOG:  connection received: host=::1 port=35616
2022-11-27 18:57:33.959 UTC [12481] LOG:  connection authorized: user=postgres database=postgres application_name=pgAdmin 4 - CONN:9734010
2022-11-27 18:57:33.961 UTC [12481] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='UNICODE';
2022-11-27 18:57:33.963 UTC [12481] LOG:  duration: 1.339 ms
2022-11-27 18:57:33.963 UTC [12481] LOG:  statement: SELECT version()
2022-11-27 18:57:33.963 UTC [12481] LOG:  duration: 0.131 ms
2022-11-27 18:57:33.963 UTC [12481] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2022-11-27 18:57:33.964 UTC [12481] LOG:  duration: 0.481 ms
2022-11-27 18:57:33.964 UTC [12481] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2022-11-27 18:57:33.965 UTC [12481] LOG:  duration: 0.450 ms
2022-11-27 18:57:33.965 UTC [12481] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2022-11-27 18:57:33.967 UTC [12481] LOG:  duration: 2.304 ms
2022-11-27 18:57:58.908 UTC [12481] ERROR:  syntax error at or near "G" at character 1
2022-11-27 18:57:58.908 UTC [12481] STATEMENT:  G'k
	#3350
	
	G'k — 17/03/2019 21:40
	J'ai mis ça il y a super longtemps ><
	Et puis, je suis seul ici
	AΔ — 17/03/2019 21:41
	C'est pire xD
	G'k — 17/03/2019 21:41
	Par contre, je suis étonné et content d'avoir été aussi prévoyant. Merci, moi du passé, d'avoir caché l'autre channel
	AΔ — 17/03/2019 21:41
	:/
	G'k — 17/03/2019 21:42
	Bon, en vrai, j'ai fait du ménage il y a très peu de temps, donc tu peux regarder
	AΔ — 17/03/2019 21:42
	Go
	Mas le droit de voir l'historique lol
	G'k — 17/03/2019 21:43
	Fait 
	AΔ — 17/03/2019 21:43
	Vise
	Vide
	G'k — 17/03/2019 21:43
	Je t'ai donné toutes les perms, ça peut pas être vide >< 
	AΔ — 17/03/2019 21:44
	Si
	G'k — 17/03/2019 21:44
	Toujours ?
	AΔ — 17/03/2019 21:44
	Ui
	G'k — 17/03/2019 21:44
	Je t'ai mis admin pourtant '-'
	Bon, osef, il y a rien d'important
	AΔ — 17/03/2019 21:45
	🤷‍♂️
	G'k — 17/03/2019 21:46
	:GWworkshopAkaShrug:
	T'es nul ><
	G'k — 22/08/2022 09:21
	Attachment file type: unknown
	MyTracks_Parcours_du_2022-08-19_15_59_45_20220819155945.kml
	269.38 KB
	G'k — 22/08/2022 18:13
	https://sn-apogee-prod.univ-cotedazur.fr/PJwebsso
	G'k — 23/08/2022 17:05
	Ultisnips Obsidian
	G'k — 27/08/2022 08:53
	DevToys
	Korben: DevToys – Le couteau suisse des développeurs.
	https://korben.info/devtoys-outils-developpeurs.html
	Korben
	DevToys – Le couteau suisse des développeurs
	Quand on est développeur, il y a parfois certains trucs dont on a besoin qui nécessite de chercher un site web ou un petit outil pour le faire rapidement. Cela peut-être générer un texte en lorem i…
	DevToys – Le couteau suisse des développeurs
	https://github.com/wesbos/awesome-uses
	GitHub
	GitHub - wesbos/awesome-uses: A list of /uses pages detailing devel...
	A list of /uses pages detailing developer setups, gear, software and configs. - GitHub - wesbos/awesome-uses: A list of /uses pages detailing developer setups, gear, software and configs.
	GitHub - wesbos/awesome-uses: A list of /uses pages detailing devel...
	G'k — 29/08/2022 09:04
	Plate-forme centralisation livre jeu série
	G'k — 31/08/2022 11:25
	Volant adaptatif vitesse
	G'k — 31/08/2022 13:28
	Git encryption
	G'k — 31/08/2022 13:52
	Réglage de volume : fonction (affine ?) pour adapter le changement à la durée de la pression
	G'k — 31/08/2022 15:22
	JSON merging : Manual Activity Watch synchronisation
	G'k — 31/08/2022 20:46
	m8T30#Nbnu5zuzNg*^ps
	G'k — 01/09/2022 23:29
	Me ghostera si ça se passe mal avec Polytech 
	G'k — 02/09/2022 10:36
	Centraliser toute mon activité : articles, vidéos...
	Meilleure historique, vu comme tree
	G'k — 03/09/2022 21:02
	https://www.femmeactuelle.fr/deco/maison-pratique/15-endroits-et-objets-que-vous-oubliez-probablement-de-nettoyer-dans-la-cuisine-2126608
	Femme Actuelle
	15 endroits et objets que vous oubliez probablement de nettoyer dan...
	Poubelle, torchons, éponges, électroménager, étagères, poignées de portes… nombreuses sont les choses que l’on oublie de nettoyer dans la cuisine alo1
	15 endroits et objets que vous oubliez probablement de nettoyer dan...
	G'k — 05/09/2022 11:17
	Xiaomi : bigpassw0rd
	G'k — 05/09/2022 15:32
	fz-566-tk
	G'k — 07/10/2022 15:35
	Découpage vertical du code. Notion intéressante. Travailler sur tous les domaines à la fois
	G'k — 11/10/2022 10:11
	Severance
	G'k — 12/10/2022 14:20
	https://v.redd.it/hagcxgoa3ct91
	reddit
	The way this ball slides down and shoots back to the wooden platform
	Posted in r/oddlysatisfying by u/MrLeeBuns • 2,050 points and 124 comments
	The way this ball slides down and shoots back to the wooden platform
	G'k — 23/10/2022 13:28
	vbv94qruc5qej58dghn7
	G'k — 04/11/2022 16:00
	https://incredible.pm/
	https://threadreaderapp.com/
	Read and Share Twitter Threads easily!
	Thread Reader helps you read and share the best of Twitter Threads
	Read and Share Twitter Threads easily!
	G'k — 11/11/2022 15:08
	https://privatebin.rinuploads.org/?8c4e35d2c9c2f30f#F18b4E4N7L4NrLoMoTG6iBjXWDmRTFHu2xmSBtJJwAv6
	G'k — 18/11/2022 18:31
	https://lms.univ-cotedazur.fr/2022/login/index.php#tabs-tree-start | LMS UCA 2022: Log in to the site - lms.univ-cotedazur.fr/
	https://www.reddit.com/r/rust/comments/yq798m/idiomatic_way_to_write_this_snippet/ | Idiomatic way to write this snippet : rust - www.reddit.com/
	https://www.reddit.com/r/rust/comments/ypr516/can_someone_recommend_good_blogs_about_rust/ | Can someone recommend good blogs about Rust? : rust - www.reddit.com/
	https://www.aei.org/carpe-diem/the-sp-500-index-out-performed-hedge-funds-over-the-last-10-years-and-it-wasnt-even-close/ | The SP 500 Index Out-performed Hedge Funds over the Last 10 Years. And It Wasn’t Even Close | American Enterprise Institute - AEI - www.aei.org/
	https://kagi.com/ | Kagi Search - kagi.com/
	https://help.kagi.com/kagi/plans/plan-types.html | Plan Types - Kagi Search User Guide - help.kagi.com/
	Expand
	message.txt
	22 KB
	G'k — 18/11/2022 18:57
	https://addons.mozilla.org/fr/firefox/addon/onetab/reviews/?score=4&page=2 | Critiques pour OneTab – Modules pour Firefox (fr)
	https://www.gettoby.com/ | Better than Bookmarks - www.gettoby.com/
	https://addons.mozilla.org/en-US/firefox/addon/simple-tab-groups/ | Simple Tab Groups – Get this Extension for 🦊 Firefox (en-US)
	https://addons.mozilla.org/en-US/firefox/addon/my-sessions/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search | MySessions – Get this Extension for 🦊 Firefox (en-US)
	https://www.youtube.com/watch?v=01mXdwgfn5A | (75) Le buff le plus INUTILE jamais octroyé !! - YouTube - www.youtube.com/
	https://www.youtube.com/watch?v=tZ5FBBnHfm4 | (75) Intro to Competitive Programming - YouTube - www.youtube.com/
	Expand
	message.txt
	39 KB
	G'k — 20/11/2022 20:51
	Pour Edmond :
	Lenovo IdeaPad Gaming 3 15ARH7 82SB0085FR
	Lenovo IdeaPad Gaming 3 15IAH7 82S90054FR 
	G'k — Yesterday at 13:11
	Mélodie protection switch
	G'k — Today at 19:51
	drop schema public cascade;
	create schema public;
	grant usage on schema public to public;
	grant create on schema public to public;
	
	CREATE TABLE pays (
	  code CHAR (2) NOT NULL PRIMARY KEY, 
	  nom VARCHAR (50) NOT NULL
	);
	
	CREATE TABLE ville (
	  id integer NOT NULL PRIMARY KEY, 
	  nom VARCHAR (50) NOT NULL, 
	  codePays CHAR (2) NOT NULL REFERENCES pays
	);
	
	CREATE TABLE voyage (
	  id integer NOT NULL PRIMARY KEY, 
	  nom character varying(30), 
	  typeVoyage CHAR (2) NOT NULL,  -- exemple : "AS" pour "Aller Simple", "AR" pour "Aller Retour"
	  prix decimal NOT NULL
	);
	
	CREATE TABLE etape (
	  idVoyage integer NOT NULL REFERENCES voyage, 
	  idVille integer NOT NULL REFERENCES ville, 
	  numOrdre integer NOT NULL, 
	  duree integer NOT NULL, 
	  CONSTRAINT cle_etape PRIMARY KEY (IdVoyage, numOrdre)
	);
	
	CREATE TABLE client (
	  id integer NOT NULL PRIMARY KEY, 
	  nom character varying(30), 
	  prenom character varying(30), 
	  adresse character varying(30), 
	  email character varying(30), 
	  pays CHAR (2) NOT NULL REFERENCES pays
	);
	
	CREATE TABLE reservation (
	  id integer NOT NULL PRIMARY KEY, 
	  nomVoyageur character varying(30), 
	  prenomVoyageur character varying(30), 
	  idVoyage integer references voyage, 
	  dateDepart Date NOT NULL, 
	  dateReservation Date NOT NULL, 
	  idClient integer references client
	);
	
	CREATE TABLE depart (
	  idVoyage integer NOT NULL references Voyage, 
	  dateDepart DATE NOT NULL, 
	  capacite integer NOT NULL, 
	  CONSTRAINT cle_depart PRIMARY KEY (IdVoyage, DateDepart)
	);
	
	-- Generate sample data
	
	INSERT INTO pays (code, nom)
	    VALUES ('FR', 'France'),
	           ('ES', 'Espagne'),
	           ('BE', 'Belgique'),
	           ('IT', 'Italie'),
	           ('CH', 'Suisse'),
	           ('DE', 'Allemagne'),
	           ('GB', 'Angleterre'),
	           ('US', 'Etats-Unis'),
	           ('CA', 'Canada'),
	           ('JP', 'Japon'),
	           ('CN', 'Chine'),
	           ('RU', 'Russie'),
	           ('BR', 'Brésil'),
	           ('AU', 'Australie'), 
	           ('NL', 'Pays-bas');
	
	INSERT INTO ville (id, nom, codePays)
	    VALUES (1, 'Paris', 'FR'),
	           (2, 'Lyon', 'FR'),
	           (3, 'Marseille', 'FR'),
	           (4, 'Nice', 'FR'),
	           (5, 'Londres', 'GB'),
	           (6, 'Madrid', 'ES'),
	           (7, 'Barcelone', 'ES'),
	           (8, 'Berlin', 'DE'),
	           (9, 'Rome', 'IT'),
	           (10, 'Florence', 'IT'),
	           (11, 'Venise', 'IT'),
	           (12, 'Bruxelles', 'BE'),
	           (13, 'Anvers', 'BE'),
	           (14, 'Bruges', 'BE'),
	           (15, 'Gand', 'BE'),
	           (16, 'Bordeaux', 'FR'),
	           (17, 'Strasbourg', 'FR'),
	           (18, 'Montpellier', 'FR'),
	           (19, 'Toulouse', 'FR'),
	           (20, 'Nantes', 'FR'),
	           (21, 'Dijon', 'FR'),
	           (22, 'Brest', 'FR'),
	           (23, 'Le Havre', 'FR'),
	... (186 lines left)
	Collapse
	message.txt
	12 KB
	﻿
	drop schema public cascade;
	create schema public;
	grant usage on schema public to public;
	grant create on schema public to public;
	
	CREATE TABLE pays (
	  code CHAR (2) NOT NULL PRIMARY KEY, 
	  nom VARCHAR (50) NOT NULL
	);
	
	CREATE TABLE ville (
	  id integer NOT NULL PRIMARY KEY, 
	  nom VARCHAR (50) NOT NULL, 
	  codePays CHAR (2) NOT NULL REFERENCES pays
	);
	
	CREATE TABLE voyage (
	  id integer NOT NULL PRIMARY KEY, 
	  nom character varying(30), 
	  typeVoyage CHAR (2) NOT NULL,  -- exemple : "AS" pour "Aller Simple", "AR" pour "Aller Retour"
	  prix decimal NOT NULL
	);
	
	CREATE TABLE etape (
	  idVoyage integer NOT NULL REFERENCES voyage, 
	  idVille integer NOT NULL REFERENCES ville, 
	  numOrdre integer NOT NULL, 
	  duree integer NOT NULL, 
	  CONSTRAINT cle_etape PRIMARY KEY (IdVoyage, numOrdre)
	);
	
	CREATE TABLE client (
	  id integer NOT NULL PRIMARY KEY, 
	  nom character varying(30), 
	  prenom character varying(30), 
	  adresse character varying(30), 
	  email character varying(30), 
	  pays CHAR (2) NOT NULL REFERENCES pays
	);
	
	CREATE TABLE reservation (
	  id integer NOT NULL PRIMARY KEY, 
	  nomVoyageur character varying(30), 
	  prenomVoyageur character varying(30), 
	  idVoyage integer references voyage, 
	  dateDepart Date NOT NULL, 
	  dateReservation Date NOT NULL, 
	  idClient integer references client
	);
	
	CREATE TABLE depart (
	  idVoyage integer NOT NULL references Voyage, 
	  dateDepart DATE NOT NULL, 
	  capacite integer NOT NULL, 
	  CONSTRAINT cle_depart PRIMARY KEY (IdVoyage, DateDepart)
	);
	
	-- Generate sample data
	
	INSERT INTO pays (code, nom)
	    VALUES ('FR', 'France'),
	           ('ES', 'Espagne'),
	           ('BE', 'Belgique'),
	           ('IT', 'Italie'),
	           ('CH', 'Suisse'),
	           ('DE', 'Allemagne'),
	           ('GB', 'Angleterre'),
	           ('US', 'Etats-Unis'),
	           ('CA', 'Canada'),
	           ('JP', 'Japon'),
	           ('CN', 'Chine'),
	           ('RU', 'Russie'),
	           ('BR', 'Brésil'),
	           ('AU', 'Australie'), 
	           ('NL', 'Pays-bas');
	
	INSERT INTO ville (id, nom, codePays)
	    VALUES (1, 'Paris', 'FR'),
	           (2, 'Lyon', 'FR'),
	           (3, 'Marseille', 'FR'),
	           (4, 'Nice', 'FR'),
	           (5, 'Londres', 'GB'),
	           (6, 'Madrid', 'ES'),
	           (7, 'Barcelone', 'ES'),
	           (8, 'Berlin', 'DE'),
	           (9, 'Rome', 'IT'),
	           (10, 'Florence', 'IT'),
	           (11, 'Venise', 'IT'),
	           (12, 'Bruxelles', 'BE'),
	           (13, 'Anvers', 'BE'),
	           (14, 'Bruges', 'BE'),
	           (15, 'Gand', 'BE'),
	           (16, 'Bordeaux', 'FR'),
	           (17, 'Strasbourg', 'FR'),
	           (18, 'Montpellier', 'FR'),
	           (19, 'Toulouse', 'FR'),
	           (20, 'Nantes', 'FR'),
	           (21, 'Dijon', 'FR'),
	           (22, 'Brest', 'FR'),
	           (23, 'Le Havre', 'FR'),
	           (24, 'Lille', 'FR'),
	           (25, 'Reims', 'FR'),
	           (26, 'Rouen', 'FR'),
	           (27, 'Tours', 'FR'),
	           (28, 'Amsterdam', 'NL'),
	           (29, 'Rotterdam', 'NL'),
	           (30, 'La Haye', 'NL'),
	           (31, 'Utrecht', 'NL'),
	           (32, 'Groningue', 'NL'),
	           (33, 'Munich', 'DE'),
	           (34, 'Hambourg', 'DE'),
	           (35, 'Cologne', 'DE'),
	           (36, 'Frankfurt', 'DE'),
	           (37, 'Leipzig', 'DE'),
	           (38, 'Dresde', 'DE'),
	           (39, 'Stuttgart', 'DE'),
	           (40, 'Bâle', 'CH'),
	           (41, 'Genève', 'CH'),
	           (42, 'Zurich', 'CH'),
	           (43, 'Lugano', 'CH'),
	           (44, 'Lausanne', 'CH');
	
	INSERT INTO voyage (id, nom, typeVoyage, prix)
	    VALUES (1, 'Paris - Londres', 'AS', 100),
	           (2, 'Paris - Londres', 'AR', 200),
	           (3, 'Paris - Madrid', 'AS', 150),
	           (4, 'Paris - Madrid', 'AR', 300),
	           (5, 'Paris - Berlin', 'AS', 150),
	           (6, 'Paris - Berlin', 'AR', 300),
	           (7, 'Paris - Rome', 'AS', 200),
	           (8, 'Paris - Rome', 'AR', 400),
	           (9, 'Paris - Bruxelles', 'AS', 100),
	           (10, 'Paris - Bruxelles', 'AR', 200),
	           (11, 'Paris - Amsterdam', 'AS', 100),
	           (12, 'Paris - Amsterdam', 'AR', 200),
	           (13, 'Paris - Munich', 'AS', 150),
	           (14, 'Paris - Munich', 'AR', 300),
	           (15, 'Paris - Bâle', 'AS', 150),
	           (16, 'Paris - Bâle', 'AR', 300),
	           (17, 'Lyon - Madrid', 'AS', 150),
	           (18, 'Lyon - Madrid', 'AR', 300),
	           (19, 'Lyon - Berlin', 'AS', 150),
	           (20, 'Lyon - Berlin', 'AR', 300),
	           (21, 'Lyon - Rome', 'AS', 200),
	           (22, 'Lyon - Rome', 'AR', 400),
	           (23, 'Lyon - Bruxelles', 'AS', 100),
	           (24, 'Lyon - Bruxelles', 'AR', 200),
	           (25, 'Lyon - Amsterdam', 'AS', 100),
	           (26, 'Lyon - Amsterdam', 'AR', 200),
	           (27, 'Lyon - Munich', 'AS', 150),
	           (28, 'Lyon - Munich', 'AR', 300),
	           (29, 'Lyon - Bâle', 'AS', 150),
	           (30, 'Lyon - Bâle', 'AR', 300),
	           (31, 'Marseille - Londres', 'AS', 100),
	           (32, 'Marseille - Londres', 'AR', 200),
	           (33, 'Marseille - Madrid', 'AS', 150),
	           (34, 'Marseille - Madrid', 'AR', 300),
	           (35, 'Marseille - Berlin', 'AS', 150),
	           (36, 'Marseille - Berlin', 'AR', 300),
	           (37, 'Marseille - Rome', 'AS', 200),
	           (38, 'Marseille - Rome', 'AR', 400),
	           (39, 'Marseille - Bruxelles', 'AS', 100),
	           (40, 'Marseille - Bruxelles', 'AR', 200),
	           (41, 'Marseille - Amsterdam', 'AS', 100),
	           (42, 'Marseille - Amsterdam', 'AR', 200),
	           (43, 'Marseille - Munich', 'AS', 150),
	           (44, 'Marseille - Munich', 'AR', 300),
	           (45, 'Marseille - Bâle', 'AS', 150),
	           (46, 'Marseille - Bâle', 'AR', 300),
	           (47, 'Nice - Londres', 'AS', 100),
	           (48, 'Nice - Londres', 'AR', 200),
	           (49, 'Nice - Madrid', 'AS', 150),
	           (50, 'Nice - Madrid', 'AR', 300),
	           (51, 'Nice - Berlin', 'AS', 150),
	           (52, 'Nice - Berlin', 'AR', 300),
	           (53, 'Nice - Rome', 'AS', 200),
	           (54, 'Nice - Rome', 'AR', 400),
	           (55, 'Nice - Bruxelles', 'AS', 100),
	           (56, 'Nice - Bruxelles', 'AR', 200);
	
	
	INSERT INTO client(id, nom, prenom, adresse, pays)
	    VALUES (1, 'Dupont', 'Jean', '1 rue de Paris', 'FR'),
	           (2, 'Durand', 'Marie', '2 rue de Londres', 'GB'),
	           (3, 'Martin', 'Paul', '3 rue de Madrid', 'ES'),
	           (4, 'Bernard', 'Pierre', '4 rue de Berlin', 'DE'),
	           (5, 'Thomas', 'Jacques', '5 rue de Rome', 'IT'),
	           (6, 'Petit', 'Michel', '6 rue de Bruxelles', 'BE'),
	           (7, 'Robert', 'Laurent', '7 rue d''Amsterdam', 'NL'),
	           (8, 'Richard', 'Alain', '8 rue de Munich', 'DE'),
	           (9, 'Durand', 'Sophie', '9 rue de Bâle', 'CH'),
	           (10, 'Moreau', 'Anne', '10 rue de Genève', 'CH');
	
	INSERT INTO reservation(id, nomVoyageur, prenomVoyageur, idVoyage, dateDepart, dateReservation, idClient)
	    VALUES (1, 'Dupont', 'Jean', 1, '2015-01-01', '2014-12-01', 1),
	           (2, 'Durand', 'Marie', 2, '2015-02-01', '2014-12-01', 2),
	           (3, 'Martin', 'Paul', 3, '2015-03-01', '2014-12-01', 3),
	           (4, 'Bernard', 'Pierre', 4, '2015-04-01', '2014-12-01', 4),
	           (5, 'Thomas', 'Jacques', 5, '2015-05-01', '2014-12-01', 5),
	           (6, 'Petit', 'Michel', 6, '2015-06-01', '2014-12-01', 6),
	           (7, 'Robert', 'Laurent', 7, '2015-07-01', '2014-12-01', 7),
	           (8, 'Richard', 'Alain', 8, '2015-08-01', '2014-12-01', 8),
	           (9, 'Durand', 'Sophie', 9, '2015-09-01', '2014-12-01', 9),
	           (10, 'Moreau', 'Anne', 10, '2015-10-01', '2014-12-01', 10),
	           (11, 'Dupont', 'Jean', 11, '2015-11-01', '2014-12-01', 1),
	           (12, 'Durand', 'Marie', 12, '2015-12-01', '2014-12-01', 2),
	           (13, 'Martin', 'Paul', 13, '2015-01-01', '2014-12-01', 3),
	           (14, 'Bernard', 'Pierre', 14, '2015-02-01', '2014-12-01', 4),
	           (15, 'Thomas', 'Jacques', 15, '2015-03-01', '2014-12-01', 5);
	
	INSERT INTO depart(idVoyage, dateDepart, capacite)
	    VALUES (1, '2015-01-01', 100),
	           (2, '2015-02-01', 100),
	           (3, '2015-03-01', 100),
	           (4, '2015-04-01', 100),
	           (5, '2015-05-01', 100),
	           (6, '2015-06-01', 100),
	           (7, '2015-07-01', 100),
	           (8, '2015-08-01', 100),
	           (9, '2015-09-01', 100),
	           (10, '2015-10-01', 100),
	           (11, '2015-11-01', 100),
	           (12, '2015-12-01', 100),
	           (13, '2015-01-01', 100),
	           (14, '2015-02-01', 100),
	           (15, '2015-03-01', 100); 
	
	
	INSERT INTO etape(idVoyage, idVille, numOrdre, duree)
	    VALUES (1, 1, 1, 1),
	           (1, 2, 2, 2),
	           (2, 2, 1, 1),
	           (2, 3, 2, 2),
	           (3, 3, 1, 1),
	           (3, 4, 2, 2),
	           (4, 4, 1, 1),
	           (4, 5, 2, 2),
	           (5, 5, 1, 1),
	           (5, 6, 2, 2),
	           (6, 6, 1, 1),
	           (6, 7, 2, 2),
	           (7, 7, 1, 1),
	           (7, 8, 2, 2),
	           (8, 8, 1, 1),
	           (8, 9, 2, 2),
	           (9, 9, 1, 1),
	           (9, 10, 2, 2),
	           (10, 10, 1, 1),
	           (10, 11, 2, 2),
	           (11, 11, 1, 1),
	           (11, 12, 2, 2),
	           (12, 12, 1, 1),
	           (12, 13, 2, 2),
	           (13, 13, 1, 1),
	           (13, 14, 2, 2),
	           (14, 14, 1, 1),
	           (14, 15, 2, 2),
	           (15, 15, 1, 1),
	           (15, 16, 2, 2),
	           (16, 16, 1, 1),
	           (16, 17, 2, 2),
	           (17, 17, 1, 1),
	           (17, 18, 2, 2),
	           (18, 18, 1, 1),
	           (18, 19, 2, 2),
	           (19, 19, 1, 1),
	           (19, 20, 2, 2);
	
	-- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	-- 3)  Afficher le nom des personnes de nationalité Française
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	message.txt
	12 KB
2022-11-27 18:58:16.651 UTC [12481] ERROR:  syntax error at or near "message" at character 11032
2022-11-27 18:58:16.651 UTC [12481] STATEMENT:  drop schema public cascade;
	create schema public;
	grant usage on schema public to public;
	grant create on schema public to public;
	
	CREATE TABLE pays (
	  code CHAR (2) NOT NULL PRIMARY KEY, 
	  nom VARCHAR (50) NOT NULL
	);
	
	CREATE TABLE ville (
	  id integer NOT NULL PRIMARY KEY, 
	  nom VARCHAR (50) NOT NULL, 
	  codePays CHAR (2) NOT NULL REFERENCES pays
	);
	
	CREATE TABLE voyage (
	  id integer NOT NULL PRIMARY KEY, 
	  nom character varying(30), 
	  typeVoyage CHAR (2) NOT NULL,  -- exemple : "AS" pour "Aller Simple", "AR" pour "Aller Retour"
	  prix decimal NOT NULL
	);
	
	CREATE TABLE etape (
	  idVoyage integer NOT NULL REFERENCES voyage, 
	  idVille integer NOT NULL REFERENCES ville, 
	  numOrdre integer NOT NULL, 
	  duree integer NOT NULL, 
	  CONSTRAINT cle_etape PRIMARY KEY (IdVoyage, numOrdre)
	);
	
	CREATE TABLE client (
	  id integer NOT NULL PRIMARY KEY, 
	  nom character varying(30), 
	  prenom character varying(30), 
	  adresse character varying(30), 
	  email character varying(30), 
	  pays CHAR (2) NOT NULL REFERENCES pays
	);
	
	CREATE TABLE reservation (
	  id integer NOT NULL PRIMARY KEY, 
	  nomVoyageur character varying(30), 
	  prenomVoyageur character varying(30), 
	  idVoyage integer references voyage, 
	  dateDepart Date NOT NULL, 
	  dateReservation Date NOT NULL, 
	  idClient integer references client
	);
	
	CREATE TABLE depart (
	  idVoyage integer NOT NULL references Voyage, 
	  dateDepart DATE NOT NULL, 
	  capacite integer NOT NULL, 
	  CONSTRAINT cle_depart PRIMARY KEY (IdVoyage, DateDepart)
	);
	
	-- Generate sample data
	
	INSERT INTO pays (code, nom)
	    VALUES ('FR', 'France'),
	           ('ES', 'Espagne'),
	           ('BE', 'Belgique'),
	           ('IT', 'Italie'),
	           ('CH', 'Suisse'),
	           ('DE', 'Allemagne'),
	           ('GB', 'Angleterre'),
	           ('US', 'Etats-Unis'),
	           ('CA', 'Canada'),
	           ('JP', 'Japon'),
	           ('CN', 'Chine'),
	           ('RU', 'Russie'),
	           ('BR', 'Brésil'),
	           ('AU', 'Australie'), 
	           ('NL', 'Pays-bas');
	
	INSERT INTO ville (id, nom, codePays)
	    VALUES (1, 'Paris', 'FR'),
	           (2, 'Lyon', 'FR'),
	           (3, 'Marseille', 'FR'),
	           (4, 'Nice', 'FR'),
	           (5, 'Londres', 'GB'),
	           (6, 'Madrid', 'ES'),
	           (7, 'Barcelone', 'ES'),
	           (8, 'Berlin', 'DE'),
	           (9, 'Rome', 'IT'),
	           (10, 'Florence', 'IT'),
	           (11, 'Venise', 'IT'),
	           (12, 'Bruxelles', 'BE'),
	           (13, 'Anvers', 'BE'),
	           (14, 'Bruges', 'BE'),
	           (15, 'Gand', 'BE'),
	           (16, 'Bordeaux', 'FR'),
	           (17, 'Strasbourg', 'FR'),
	           (18, 'Montpellier', 'FR'),
	           (19, 'Toulouse', 'FR'),
	           (20, 'Nantes', 'FR'),
	           (21, 'Dijon', 'FR'),
	           (22, 'Brest', 'FR'),
	           (23, 'Le Havre', 'FR'),
	           (24, 'Lille', 'FR'),
	           (25, 'Reims', 'FR'),
	           (26, 'Rouen', 'FR'),
	           (27, 'Tours', 'FR'),
	           (28, 'Amsterdam', 'NL'),
	           (29, 'Rotterdam', 'NL'),
	           (30, 'La Haye', 'NL'),
	           (31, 'Utrecht', 'NL'),
	           (32, 'Groningue', 'NL'),
	           (33, 'Munich', 'DE'),
	           (34, 'Hambourg', 'DE'),
	           (35, 'Cologne', 'DE'),
	           (36, 'Frankfurt', 'DE'),
	           (37, 'Leipzig', 'DE'),
	           (38, 'Dresde', 'DE'),
	           (39, 'Stuttgart', 'DE'),
	           (40, 'Bâle', 'CH'),
	           (41, 'Genève', 'CH'),
	           (42, 'Zurich', 'CH'),
	           (43, 'Lugano', 'CH'),
	           (44, 'Lausanne', 'CH');
	
	INSERT INTO voyage (id, nom, typeVoyage, prix)
	    VALUES (1, 'Paris - Londres', 'AS', 100),
	           (2, 'Paris - Londres', 'AR', 200),
	           (3, 'Paris - Madrid', 'AS', 150),
	           (4, 'Paris - Madrid', 'AR', 300),
	           (5, 'Paris - Berlin', 'AS', 150),
	           (6, 'Paris - Berlin', 'AR', 300),
	           (7, 'Paris - Rome', 'AS', 200),
	           (8, 'Paris - Rome', 'AR', 400),
	           (9, 'Paris - Bruxelles', 'AS', 100),
	           (10, 'Paris - Bruxelles', 'AR', 200),
	           (11, 'Paris - Amsterdam', 'AS', 100),
	           (12, 'Paris - Amsterdam', 'AR', 200),
	           (13, 'Paris - Munich', 'AS', 150),
	           (14, 'Paris - Munich', 'AR', 300),
	           (15, 'Paris - Bâle', 'AS', 150),
	           (16, 'Paris - Bâle', 'AR', 300),
	           (17, 'Lyon - Madrid', 'AS', 150),
	           (18, 'Lyon - Madrid', 'AR', 300),
	           (19, 'Lyon - Berlin', 'AS', 150),
	           (20, 'Lyon - Berlin', 'AR', 300),
	           (21, 'Lyon - Rome', 'AS', 200),
	           (22, 'Lyon - Rome', 'AR', 400),
	           (23, 'Lyon - Bruxelles', 'AS', 100),
	           (24, 'Lyon - Bruxelles', 'AR', 200),
	           (25, 'Lyon - Amsterdam', 'AS', 100),
	           (26, 'Lyon - Amsterdam', 'AR', 200),
	           (27, 'Lyon - Munich', 'AS', 150),
	           (28, 'Lyon - Munich', 'AR', 300),
	           (29, 'Lyon - Bâle', 'AS', 150),
	           (30, 'Lyon - Bâle', 'AR', 300),
	           (31, 'Marseille - Londres', 'AS', 100),
	           (32, 'Marseille - Londres', 'AR', 200),
	           (33, 'Marseille - Madrid', 'AS', 150),
	           (34, 'Marseille - Madrid', 'AR', 300),
	           (35, 'Marseille - Berlin', 'AS', 150),
	           (36, 'Marseille - Berlin', 'AR', 300),
	           (37, 'Marseille - Rome', 'AS', 200),
	           (38, 'Marseille - Rome', 'AR', 400),
	           (39, 'Marseille - Bruxelles', 'AS', 100),
	           (40, 'Marseille - Bruxelles', 'AR', 200),
	           (41, 'Marseille - Amsterdam', 'AS', 100),
	           (42, 'Marseille - Amsterdam', 'AR', 200),
	           (43, 'Marseille - Munich', 'AS', 150),
	           (44, 'Marseille - Munich', 'AR', 300),
	           (45, 'Marseille - Bâle', 'AS', 150),
	           (46, 'Marseille - Bâle', 'AR', 300),
	           (47, 'Nice - Londres', 'AS', 100),
	           (48, 'Nice - Londres', 'AR', 200),
	           (49, 'Nice - Madrid', 'AS', 150),
	           (50, 'Nice - Madrid', 'AR', 300),
	           (51, 'Nice - Berlin', 'AS', 150),
	           (52, 'Nice - Berlin', 'AR', 300),
	           (53, 'Nice - Rome', 'AS', 200),
	           (54, 'Nice - Rome', 'AR', 400),
	           (55, 'Nice - Bruxelles', 'AS', 100),
	           (56, 'Nice - Bruxelles', 'AR', 200);
	
	
	INSERT INTO client(id, nom, prenom, adresse, pays)
	    VALUES (1, 'Dupont', 'Jean', '1 rue de Paris', 'FR'),
	           (2, 'Durand', 'Marie', '2 rue de Londres', 'GB'),
	           (3, 'Martin', 'Paul', '3 rue de Madrid', 'ES'),
	           (4, 'Bernard', 'Pierre', '4 rue de Berlin', 'DE'),
	           (5, 'Thomas', 'Jacques', '5 rue de Rome', 'IT'),
	           (6, 'Petit', 'Michel', '6 rue de Bruxelles', 'BE'),
	           (7, 'Robert', 'Laurent', '7 rue d''Amsterdam', 'NL'),
	           (8, 'Richard', 'Alain', '8 rue de Munich', 'DE'),
	           (9, 'Durand', 'Sophie', '9 rue de Bâle', 'CH'),
	           (10, 'Moreau', 'Anne', '10 rue de Genève', 'CH');
	
	INSERT INTO reservation(id, nomVoyageur, prenomVoyageur, idVoyage, dateDepart, dateReservation, idClient)
	    VALUES (1, 'Dupont', 'Jean', 1, '2015-01-01', '2014-12-01', 1),
	           (2, 'Durand', 'Marie', 2, '2015-02-01', '2014-12-01', 2),
	           (3, 'Martin', 'Paul', 3, '2015-03-01', '2014-12-01', 3),
	           (4, 'Bernard', 'Pierre', 4, '2015-04-01', '2014-12-01', 4),
	           (5, 'Thomas', 'Jacques', 5, '2015-05-01', '2014-12-01', 5),
	           (6, 'Petit', 'Michel', 6, '2015-06-01', '2014-12-01', 6),
	           (7, 'Robert', 'Laurent', 7, '2015-07-01', '2014-12-01', 7),
	           (8, 'Richard', 'Alain', 8, '2015-08-01', '2014-12-01', 8),
	           (9, 'Durand', 'Sophie', 9, '2015-09-01', '2014-12-01', 9),
	           (10, 'Moreau', 'Anne', 10, '2015-10-01', '2014-12-01', 10),
	           (11, 'Dupont', 'Jean', 11, '2015-11-01', '2014-12-01', 1),
	           (12, 'Durand', 'Marie', 12, '2015-12-01', '2014-12-01', 2),
	           (13, 'Martin', 'Paul', 13, '2015-01-01', '2014-12-01', 3),
	           (14, 'Bernard', 'Pierre', 14, '2015-02-01', '2014-12-01', 4),
	           (15, 'Thomas', 'Jacques', 15, '2015-03-01', '2014-12-01', 5);
	
	INSERT INTO depart(idVoyage, dateDepart, capacite)
	    VALUES (1, '2015-01-01', 100),
	           (2, '2015-02-01', 100),
	           (3, '2015-03-01', 100),
	           (4, '2015-04-01', 100),
	           (5, '2015-05-01', 100),
	           (6, '2015-06-01', 100),
	           (7, '2015-07-01', 100),
	           (8, '2015-08-01', 100),
	           (9, '2015-09-01', 100),
	           (10, '2015-10-01', 100),
	           (11, '2015-11-01', 100),
	           (12, '2015-12-01', 100),
	           (13, '2015-01-01', 100),
	           (14, '2015-02-01', 100),
	           (15, '2015-03-01', 100); 
	
	
	INSERT INTO etape(idVoyage, idVille, numOrdre, duree)
	    VALUES (1, 1, 1, 1),
	           (1, 2, 2, 2),
	           (2, 2, 1, 1),
	           (2, 3, 2, 2),
	           (3, 3, 1, 1),
	           (3, 4, 2, 2),
	           (4, 4, 1, 1),
	           (4, 5, 2, 2),
	           (5, 5, 1, 1),
	           (5, 6, 2, 2),
	           (6, 6, 1, 1),
	           (6, 7, 2, 2),
	           (7, 7, 1, 1),
	           (7, 8, 2, 2),
	           (8, 8, 1, 1),
	           (8, 9, 2, 2),
	           (9, 9, 1, 1),
	           (9, 10, 2, 2),
	           (10, 10, 1, 1),
	           (10, 11, 2, 2),
	           (11, 11, 1, 1),
	           (11, 12, 2, 2),
	           (12, 12, 1, 1),
	           (12, 13, 2, 2),
	           (13, 13, 1, 1),
	           (13, 14, 2, 2),
	           (14, 14, 1, 1),
	           (14, 15, 2, 2),
	           (15, 15, 1, 1),
	           (15, 16, 2, 2),
	           (16, 16, 1, 1),
	           (16, 17, 2, 2),
	           (17, 17, 1, 1),
	           (17, 18, 2, 2),
	           (18, 18, 1, 1),
	           (18, 19, 2, 2),
	           (19, 19, 1, 1),
	           (19, 20, 2, 2);
	
	-- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	-- 3)  Afficher le nom des personnes de nationalité Française
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	message.txt
	12 KB
2022-11-27 18:58:22.475 UTC [12481] LOG:  statement: drop schema public cascade;
	create schema public;
	grant usage on schema public to public;
	grant create on schema public to public;
	
	CREATE TABLE pays (
	  code CHAR (2) NOT NULL PRIMARY KEY, 
	  nom VARCHAR (50) NOT NULL
	);
	
	CREATE TABLE ville (
	  id integer NOT NULL PRIMARY KEY, 
	  nom VARCHAR (50) NOT NULL, 
	  codePays CHAR (2) NOT NULL REFERENCES pays
	);
	
	CREATE TABLE voyage (
	  id integer NOT NULL PRIMARY KEY, 
	  nom character varying(30), 
	  typeVoyage CHAR (2) NOT NULL,  -- exemple : "AS" pour "Aller Simple", "AR" pour "Aller Retour"
	  prix decimal NOT NULL
	);
	
	CREATE TABLE etape (
	  idVoyage integer NOT NULL REFERENCES voyage, 
	  idVille integer NOT NULL REFERENCES ville, 
	  numOrdre integer NOT NULL, 
	  duree integer NOT NULL, 
	  CONSTRAINT cle_etape PRIMARY KEY (IdVoyage, numOrdre)
	);
	
	CREATE TABLE client (
	  id integer NOT NULL PRIMARY KEY, 
	  nom character varying(30), 
	  prenom character varying(30), 
	  adresse character varying(30), 
	  email character varying(30), 
	  pays CHAR (2) NOT NULL REFERENCES pays
	);
	
	CREATE TABLE reservation (
	  id integer NOT NULL PRIMARY KEY, 
	  nomVoyageur character varying(30), 
	  prenomVoyageur character varying(30), 
	  idVoyage integer references voyage, 
	  dateDepart Date NOT NULL, 
	  dateReservation Date NOT NULL, 
	  idClient integer references client
	);
	
	CREATE TABLE depart (
	  idVoyage integer NOT NULL references Voyage, 
	  dateDepart DATE NOT NULL, 
	  capacite integer NOT NULL, 
	  CONSTRAINT cle_depart PRIMARY KEY (IdVoyage, DateDepart)
	);
	
	-- Generate sample data
	
	INSERT INTO pays (code, nom)
	    VALUES ('FR', 'France'),
	           ('ES', 'Espagne'),
	           ('BE', 'Belgique'),
	           ('IT', 'Italie'),
	           ('CH', 'Suisse'),
	           ('DE', 'Allemagne'),
	           ('GB', 'Angleterre'),
	           ('US', 'Etats-Unis'),
	           ('CA', 'Canada'),
	           ('JP', 'Japon'),
	           ('CN', 'Chine'),
	           ('RU', 'Russie'),
	           ('BR', 'Brésil'),
	           ('AU', 'Australie'), 
	           ('NL', 'Pays-bas');
	
	INSERT INTO ville (id, nom, codePays)
	    VALUES (1, 'Paris', 'FR'),
	           (2, 'Lyon', 'FR'),
	           (3, 'Marseille', 'FR'),
	           (4, 'Nice', 'FR'),
	           (5, 'Londres', 'GB'),
	           (6, 'Madrid', 'ES'),
	           (7, 'Barcelone', 'ES'),
	           (8, 'Berlin', 'DE'),
	           (9, 'Rome', 'IT'),
	           (10, 'Florence', 'IT'),
	           (11, 'Venise', 'IT'),
	           (12, 'Bruxelles', 'BE'),
	           (13, 'Anvers', 'BE'),
	           (14, 'Bruges', 'BE'),
	           (15, 'Gand', 'BE'),
	           (16, 'Bordeaux', 'FR'),
	           (17, 'Strasbourg', 'FR'),
	           (18, 'Montpellier', 'FR'),
	           (19, 'Toulouse', 'FR'),
	           (20, 'Nantes', 'FR'),
	           (21, 'Dijon', 'FR'),
	           (22, 'Brest', 'FR'),
	           (23, 'Le Havre', 'FR'),
	           (24, 'Lille', 'FR'),
	           (25, 'Reims', 'FR'),
	           (26, 'Rouen', 'FR'),
	           (27, 'Tours', 'FR'),
	           (28, 'Amsterdam', 'NL'),
	           (29, 'Rotterdam', 'NL'),
	           (30, 'La Haye', 'NL'),
	           (31, 'Utrecht', 'NL'),
	           (32, 'Groningue', 'NL'),
	           (33, 'Munich', 'DE'),
	           (34, 'Hambourg', 'DE'),
	           (35, 'Cologne', 'DE'),
	           (36, 'Frankfurt', 'DE'),
	           (37, 'Leipzig', 'DE'),
	           (38, 'Dresde', 'DE'),
	           (39, 'Stuttgart', 'DE'),
	           (40, 'Bâle', 'CH'),
	           (41, 'Genève', 'CH'),
	           (42, 'Zurich', 'CH'),
	           (43, 'Lugano', 'CH'),
	           (44, 'Lausanne', 'CH');
	
	INSERT INTO voyage (id, nom, typeVoyage, prix)
	    VALUES (1, 'Paris - Londres', 'AS', 100),
	           (2, 'Paris - Londres', 'AR', 200),
	           (3, 'Paris - Madrid', 'AS', 150),
	           (4, 'Paris - Madrid', 'AR', 300),
	           (5, 'Paris - Berlin', 'AS', 150),
	           (6, 'Paris - Berlin', 'AR', 300),
	           (7, 'Paris - Rome', 'AS', 200),
	           (8, 'Paris - Rome', 'AR', 400),
	           (9, 'Paris - Bruxelles', 'AS', 100),
	           (10, 'Paris - Bruxelles', 'AR', 200),
	           (11, 'Paris - Amsterdam', 'AS', 100),
	           (12, 'Paris - Amsterdam', 'AR', 200),
	           (13, 'Paris - Munich', 'AS', 150),
	           (14, 'Paris - Munich', 'AR', 300),
	           (15, 'Paris - Bâle', 'AS', 150),
	           (16, 'Paris - Bâle', 'AR', 300),
	           (17, 'Lyon - Madrid', 'AS', 150),
	           (18, 'Lyon - Madrid', 'AR', 300),
	           (19, 'Lyon - Berlin', 'AS', 150),
	           (20, 'Lyon - Berlin', 'AR', 300),
	           (21, 'Lyon - Rome', 'AS', 200),
	           (22, 'Lyon - Rome', 'AR', 400),
	           (23, 'Lyon - Bruxelles', 'AS', 100),
	           (24, 'Lyon - Bruxelles', 'AR', 200),
	           (25, 'Lyon - Amsterdam', 'AS', 100),
	           (26, 'Lyon - Amsterdam', 'AR', 200),
	           (27, 'Lyon - Munich', 'AS', 150),
	           (28, 'Lyon - Munich', 'AR', 300),
	           (29, 'Lyon - Bâle', 'AS', 150),
	           (30, 'Lyon - Bâle', 'AR', 300),
	           (31, 'Marseille - Londres', 'AS', 100),
	           (32, 'Marseille - Londres', 'AR', 200),
	           (33, 'Marseille - Madrid', 'AS', 150),
	           (34, 'Marseille - Madrid', 'AR', 300),
	           (35, 'Marseille - Berlin', 'AS', 150),
	           (36, 'Marseille - Berlin', 'AR', 300),
	           (37, 'Marseille - Rome', 'AS', 200),
	           (38, 'Marseille - Rome', 'AR', 400),
	           (39, 'Marseille - Bruxelles', 'AS', 100),
	           (40, 'Marseille - Bruxelles', 'AR', 200),
	           (41, 'Marseille - Amsterdam', 'AS', 100),
	           (42, 'Marseille - Amsterdam', 'AR', 200),
	           (43, 'Marseille - Munich', 'AS', 150),
	           (44, 'Marseille - Munich', 'AR', 300),
	           (45, 'Marseille - Bâle', 'AS', 150),
	           (46, 'Marseille - Bâle', 'AR', 300),
	           (47, 'Nice - Londres', 'AS', 100),
	           (48, 'Nice - Londres', 'AR', 200),
	           (49, 'Nice - Madrid', 'AS', 150),
	           (50, 'Nice - Madrid', 'AR', 300),
	           (51, 'Nice - Berlin', 'AS', 150),
	           (52, 'Nice - Berlin', 'AR', 300),
	           (53, 'Nice - Rome', 'AS', 200),
	           (54, 'Nice - Rome', 'AR', 400),
	           (55, 'Nice - Bruxelles', 'AS', 100),
	           (56, 'Nice - Bruxelles', 'AR', 200);
	
	
	INSERT INTO client(id, nom, prenom, adresse, pays)
	    VALUES (1, 'Dupont', 'Jean', '1 rue de Paris', 'FR'),
	           (2, 'Durand', 'Marie', '2 rue de Londres', 'GB'),
	           (3, 'Martin', 'Paul', '3 rue de Madrid', 'ES'),
	           (4, 'Bernard', 'Pierre', '4 rue de Berlin', 'DE'),
	           (5, 'Thomas', 'Jacques', '5 rue de Rome', 'IT'),
	           (6, 'Petit', 'Michel', '6 rue de Bruxelles', 'BE'),
	           (7, 'Robert', 'Laurent', '7 rue d''Amsterdam', 'NL'),
	           (8, 'Richard', 'Alain', '8 rue de Munich', 'DE'),
	           (9, 'Durand', 'Sophie', '9 rue de Bâle', 'CH'),
	           (10, 'Moreau', 'Anne', '10 rue de Genève', 'CH');
	
	INSERT INTO reservation(id, nomVoyageur, prenomVoyageur, idVoyage, dateDepart, dateReservation, idClient)
	    VALUES (1, 'Dupont', 'Jean', 1, '2015-01-01', '2014-12-01', 1),
	           (2, 'Durand', 'Marie', 2, '2015-02-01', '2014-12-01', 2),
	           (3, 'Martin', 'Paul', 3, '2015-03-01', '2014-12-01', 3),
	           (4, 'Bernard', 'Pierre', 4, '2015-04-01', '2014-12-01', 4),
	           (5, 'Thomas', 'Jacques', 5, '2015-05-01', '2014-12-01', 5),
	           (6, 'Petit', 'Michel', 6, '2015-06-01', '2014-12-01', 6),
	           (7, 'Robert', 'Laurent', 7, '2015-07-01', '2014-12-01', 7),
	           (8, 'Richard', 'Alain', 8, '2015-08-01', '2014-12-01', 8),
	           (9, 'Durand', 'Sophie', 9, '2015-09-01', '2014-12-01', 9),
	           (10, 'Moreau', 'Anne', 10, '2015-10-01', '2014-12-01', 10),
	           (11, 'Dupont', 'Jean', 11, '2015-11-01', '2014-12-01', 1),
	           (12, 'Durand', 'Marie', 12, '2015-12-01', '2014-12-01', 2),
	           (13, 'Martin', 'Paul', 13, '2015-01-01', '2014-12-01', 3),
	           (14, 'Bernard', 'Pierre', 14, '2015-02-01', '2014-12-01', 4),
	           (15, 'Thomas', 'Jacques', 15, '2015-03-01', '2014-12-01', 5);
	
	INSERT INTO depart(idVoyage, dateDepart, capacite)
	    VALUES (1, '2015-01-01', 100),
	           (2, '2015-02-01', 100),
	           (3, '2015-03-01', 100),
	           (4, '2015-04-01', 100),
	           (5, '2015-05-01', 100),
	           (6, '2015-06-01', 100),
	           (7, '2015-07-01', 100),
	           (8, '2015-08-01', 100),
	           (9, '2015-09-01', 100),
	           (10, '2015-10-01', 100),
	           (11, '2015-11-01', 100),
	           (12, '2015-12-01', 100),
	           (13, '2015-01-01', 100),
	           (14, '2015-02-01', 100),
	           (15, '2015-03-01', 100); 
	
	
	INSERT INTO etape(idVoyage, idVille, numOrdre, duree)
	    VALUES (1, 1, 1, 1),
	           (1, 2, 2, 2),
	           (2, 2, 1, 1),
	           (2, 3, 2, 2),
	           (3, 3, 1, 1),
	           (3, 4, 2, 2),
	           (4, 4, 1, 1),
	           (4, 5, 2, 2),
	           (5, 5, 1, 1),
	           (5, 6, 2, 2),
	           (6, 6, 1, 1),
	           (6, 7, 2, 2),
	           (7, 7, 1, 1),
	           (7, 8, 2, 2),
	           (8, 8, 1, 1),
	           (8, 9, 2, 2),
	           (9, 9, 1, 1),
	           (9, 10, 2, 2),
	           (10, 10, 1, 1),
	           (10, 11, 2, 2),
	           (11, 11, 1, 1),
	           (11, 12, 2, 2),
	           (12, 12, 1, 1),
	           (12, 13, 2, 2),
	           (13, 13, 1, 1),
	           (13, 14, 2, 2),
	           (14, 14, 1, 1),
	           (14, 15, 2, 2),
	           (15, 15, 1, 1),
	           (15, 16, 2, 2),
	           (16, 16, 1, 1),
	           (16, 17, 2, 2),
	           (17, 17, 1, 1),
	           (17, 18, 2, 2),
	           (18, 18, 1, 1),
	           (18, 19, 2, 2),
	           (19, 19, 1, 1),
	           (19, 20, 2, 2);
	
	-- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	-- 3)  Afficher le nom des personnes de nationalité Française
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 18:58:22.553 UTC [12481] LOG:  duration: 78.631 ms
2022-11-27 19:01:04.268 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	-- 3)  Afficher le nom des personnes de nationalité Française
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:01:04.269 UTC [12481] LOG:  duration: 0.872 ms
2022-11-27 19:01:04.367 UTC [12481] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16848::oid
	    AND at.attnum > 0
	    AND at.attisdropped = FALSE
	
2022-11-27 19:01:04.369 UTC [12481] LOG:  duration: 2.217 ms
2022-11-27 19:01:04.382 UTC [12481] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16848::oid AND attnum = ANY (
	    (SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	    AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND rel.oid = 16848::oid)::oid[])
	
2022-11-27 19:01:04.384 UTC [12481] LOG:  duration: 2.141 ms
2022-11-27 19:01:04.422 UTC [12481] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	WHERE
	    att.attrelid = 16848::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2022-11-27 19:01:04.426 UTC [12481] LOG:  duration: 4.331 ms
2022-11-27 19:01:04.429 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (1043, 1042) ORDER BY oid;
2022-11-27 19:01:04.430 UTC [12481] LOG:  duration: 0.598 ms
2022-11-27 19:55:08.316 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like '%Paris';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:55:08.317 UTC [12481] LOG:  duration: 0.865 ms
2022-11-27 19:55:08.462 UTC [12481] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16848::oid
	    AND at.attnum > 0
	    AND at.attisdropped = FALSE
	
2022-11-27 19:55:08.463 UTC [12481] LOG:  duration: 0.674 ms
2022-11-27 19:55:08.464 UTC [12481] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16848::oid AND attnum = ANY (
	    (SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	    AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND rel.oid = 16848::oid)::oid[])
	
2022-11-27 19:55:08.465 UTC [12481] LOG:  duration: 1.016 ms
2022-11-27 19:55:08.467 UTC [12481] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	WHERE
	    att.attrelid = 16848::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2022-11-27 19:55:08.468 UTC [12481] LOG:  duration: 1.901 ms
2022-11-27 19:55:08.514 UTC [12481] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16848;
	
2022-11-27 19:55:08.514 UTC [12481] LOG:  duration: 0.536 ms
2022-11-27 19:55:08.518 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (1043, 23) ORDER BY oid;
2022-11-27 19:55:08.518 UTC [12481] LOG:  duration: 0.449 ms
2022-11-27 19:55:15.569 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:55:15.570 UTC [12481] LOG:  duration: 0.593 ms
2022-11-27 19:55:15.660 UTC [12481] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16848::oid
	    AND at.attnum > 0
	    AND at.attisdropped = FALSE
	
2022-11-27 19:55:15.661 UTC [12481] LOG:  duration: 0.987 ms
2022-11-27 19:55:15.662 UTC [12481] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16848::oid AND attnum = ANY (
	    (SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	    AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND rel.oid = 16848::oid)::oid[])
	
2022-11-27 19:55:15.663 UTC [12481] LOG:  duration: 0.884 ms
2022-11-27 19:55:15.664 UTC [12481] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	WHERE
	    att.attrelid = 16848::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2022-11-27 19:55:15.666 UTC [12481] LOG:  duration: 1.584 ms
2022-11-27 19:55:15.668 UTC [12481] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16848;
	
2022-11-27 19:55:15.668 UTC [12481] LOG:  duration: 0.436 ms
2022-11-27 19:55:15.671 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (1043, 23) ORDER BY oid;
2022-11-27 19:55:15.671 UTC [12481] LOG:  duration: 0.446 ms
2022-11-27 19:55:46.892 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	select nom from client where pays = "France";
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:55:46.893 UTC [12481] ERROR:  column "France" does not exist at character 348
2022-11-27 19:55:46.893 UTC [12481] STATEMENT:  -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	select nom from client where pays = "France";
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:55:58.909 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	select nom from client where pays = 'France';
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:55:58.909 UTC [12481] LOG:  duration: 0.669 ms
2022-11-27 19:55:59.003 UTC [12481] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16870::oid
	    AND at.attnum > 0
	    AND at.attisdropped = FALSE
	
2022-11-27 19:55:59.004 UTC [12481] LOG:  duration: 0.857 ms
2022-11-27 19:55:59.005 UTC [12481] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16870::oid AND attnum = ANY (
	    (SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	    AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND rel.oid = 16870::oid)::oid[])
	
2022-11-27 19:55:59.006 UTC [12481] LOG:  duration: 0.905 ms
2022-11-27 19:55:59.008 UTC [12481] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	WHERE
	    att.attrelid = 16870::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2022-11-27 19:55:59.010 UTC [12481] LOG:  duration: 1.818 ms
2022-11-27 19:55:59.014 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (1043) ORDER BY oid;
2022-11-27 19:55:59.014 UTC [12481] LOG:  duration: 0.381 ms
2022-11-27 19:56:28.627 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	select nom from client where pays = (select code from pays where nom = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:56:28.632 UTC [12481] LOG:  duration: 5.906 ms
2022-11-27 19:56:28.759 UTC [12481] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16870::oid
	    AND at.attnum > 0
	    AND at.attisdropped = FALSE
	
2022-11-27 19:56:28.760 UTC [12481] LOG:  duration: 0.790 ms
2022-11-27 19:56:28.762 UTC [12481] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16870::oid AND attnum = ANY (
	    (SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	    AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND rel.oid = 16870::oid)::oid[])
	
2022-11-27 19:56:28.763 UTC [12481] LOG:  duration: 1.134 ms
2022-11-27 19:56:28.765 UTC [12481] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	WHERE
	    att.attrelid = 16870::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2022-11-27 19:56:28.767 UTC [12481] LOG:  duration: 2.117 ms
2022-11-27 19:56:28.771 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (1043) ORDER BY oid;
2022-11-27 19:56:28.771 UTC [12481] LOG:  duration: 0.406 ms
2022-11-27 19:58:05.803 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	select nom from client where pays = (select code from pays where nom = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	select id from reservation 
	where id in (select id from client where (prenom = 'Jean' and nom 'Dupont'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:58:05.804 UTC [12481] ERROR:  type "nom" does not exist at character 561
2022-11-27 19:58:05.804 UTC [12481] STATEMENT:  -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	select nom from client where pays = (select code from pays where nom = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	select id from reservation 
	where id in (select id from client where (prenom = 'Jean' and nom 'Dupont'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:58:20.811 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	select nom, typeVoyage from voyage;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	select nom, id from voyage where nom like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	select nom from client where pays = (select code from pays where nom = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	select id from reservation 
	where id in (select id from client where (prenom = 'Jean' and nom = 'Dupont'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:58:20.811 UTC [12481] LOG:  duration: 0.932 ms
2022-11-27 19:58:20.898 UTC [12481] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16880::oid
	    AND at.attnum > 0
	    AND at.attisdropped = FALSE
	
2022-11-27 19:58:20.898 UTC [12481] LOG:  duration: 0.697 ms
2022-11-27 19:58:20.901 UTC [12481] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16880::oid AND attnum = ANY (
	    (SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	    AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND rel.oid = 16880::oid)::oid[])
	
2022-11-27 19:58:20.902 UTC [12481] LOG:  duration: 0.722 ms
2022-11-27 19:58:20.905 UTC [12481] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	WHERE
	    att.attrelid = 16880::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2022-11-27 19:58:20.906 UTC [12481] LOG:  duration: 1.801 ms
2022-11-27 19:58:20.908 UTC [12481] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16880;
	
2022-11-27 19:58:20.908 UTC [12481] LOG:  duration: 0.429 ms
2022-11-27 19:58:20.912 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (23) ORDER BY oid;
2022-11-27 19:58:20.912 UTC [12481] LOG:  duration: 0.337 ms
2022-11-27 19:59:00.385 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	SELECT NOM,
		TYPEVOYAGE
	FROM VOYAGE;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	SELECT NOM, ID
	FROM VOYAGE
	WHERE NOM like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	SELECT NOM
	FROM CLIENT
	WHERE PAYS =
			(SELECT CODE
				FROM PAYS
				WHERE NOM = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	SELECT ID
	FROM RESERVATION
	WHERE ID in
			(SELECT ID
				FROM CLIENT
				WHERE (PRENOM = 'Jean'
											AND NOM = 'Dupont')
					OR (PRENOM = 'Marie'
									AND NOM = 'Durand'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes ayant eu lieu dans la ville de Paris ?
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:59:00.386 UTC [12481] LOG:  duration: 0.854 ms
2022-11-27 19:59:00.482 UTC [12481] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16880::oid
	    AND at.attnum > 0
	    AND at.attisdropped = FALSE
	
2022-11-27 19:59:00.482 UTC [12481] LOG:  duration: 0.503 ms
2022-11-27 19:59:00.483 UTC [12481] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	WHERE attrelid=16880::oid AND attnum = ANY (
	    (SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	    AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND rel.oid = 16880::oid)::oid[])
	
2022-11-27 19:59:00.484 UTC [12481] LOG:  duration: 0.733 ms
2022-11-27 19:59:00.485 UTC [12481] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	WHERE
	    att.attrelid = 16880::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2022-11-27 19:59:00.487 UTC [12481] LOG:  duration: 1.719 ms
2022-11-27 19:59:00.489 UTC [12481] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16880;
	
2022-11-27 19:59:00.489 UTC [12481] LOG:  duration: 0.443 ms
2022-11-27 19:59:00.494 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (23) ORDER BY oid;
2022-11-27 19:59:00.494 UTC [12481] LOG:  duration: 0.456 ms
2022-11-27 19:59:54.813 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	SELECT NOM,
		TYPEVOYAGE
	FROM VOYAGE;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	SELECT NOM, ID
	FROM VOYAGE
	WHERE NOM like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	SELECT NOM
	FROM CLIENT
	WHERE PAYS =
			(SELECT CODE
				FROM PAYS
				WHERE NOM = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	SELECT ID
	FROM RESERVATION
	WHERE ID in
			(SELECT ID
				FROM CLIENT
				WHERE (PRENOM = 'Jean'
											AND NOM = 'Dupont')
					OR (PRENOM = 'Marie'
									AND NOM = 'Durand'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes
	-- ayant eu lieu dans la ville de Paris ?
	
	select sum(duree)
	from etape;
	
	
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 19:59:54.821 UTC [12481] LOG:  duration: 8.050 ms
2022-11-27 19:59:54.908 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (20) ORDER BY oid;
2022-11-27 19:59:54.909 UTC [12481] LOG:  duration: 0.456 ms
2022-11-27 20:00:22.507 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	SELECT NOM,
		TYPEVOYAGE
	FROM VOYAGE;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	SELECT NOM, ID
	FROM VOYAGE
	WHERE NOM like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	SELECT NOM
	FROM CLIENT
	WHERE PAYS =
			(SELECT CODE
				FROM PAYS
				WHERE NOM = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	SELECT ID
	FROM RESERVATION
	WHERE ID in
			(SELECT ID
				FROM CLIENT
				WHERE (PRENOM = 'Jean'
											AND NOM = 'Dupont')
					OR (PRENOM = 'Marie'
									AND NOM = 'Durand'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes
	-- ayant eu lieu dans la ville de Paris ?
	
	select sum(duree)
	from etape
	where idVille = (select id from ville where nom = 'Paris')
	;
	
	
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des voyages ayant eu lieu avant le 10/11/2015 ?
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 20:00:22.508 UTC [12481] LOG:  duration: 1.563 ms
2022-11-27 20:00:22.590 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (20) ORDER BY oid;
2022-11-27 20:00:22.590 UTC [12481] LOG:  duration: 0.458 ms
2022-11-27 20:05:05.051 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	SELECT NOM,
		TYPEVOYAGE
	FROM VOYAGE;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	SELECT NOM, ID
	FROM VOYAGE
	WHERE NOM like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	SELECT NOM
	FROM CLIENT
	WHERE PAYS =
			(SELECT CODE
				FROM PAYS
				WHERE NOM = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	SELECT ID
	FROM RESERVATION
	WHERE ID in
			(SELECT ID
				FROM CLIENT
				WHERE (PRENOM = 'Jean'
											AND NOM = 'Dupont')
					OR (PRENOM = 'Marie'
									AND NOM = 'Durand'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes
	-- ayant eu lieu dans la ville de Paris ?
	
	SELECT SUM(DUREE)
	FROM ETAPE
	WHERE IDVILLE =
			(SELECT ID
				FROM VILLE
				WHERE NOM = 'Paris') ;
	
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des 
	-- voyages ayant eu lieu avant le 10/11/2015 ?
	 
	SELECT COUNT(*)
	FROM ETAPE 
	WHERE IDVOYAGE = 
			(SELECT ID
				FROM VOYAGE
				JOIN DEPART ON IDVOYAGE = ID 
				WHERE DATEDEPART < '10-11-2015')
				AND idVille = (SELECT ID
				FROM VILLE
				WHERE NOM = 'Paris') ;
	
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 20:05:05.053 UTC [12481] ERROR:  more than one row returned by a subquery used as an expression
2022-11-27 20:05:05.053 UTC [12481] STATEMENT:  -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	SELECT NOM,
		TYPEVOYAGE
	FROM VOYAGE;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	SELECT NOM, ID
	FROM VOYAGE
	WHERE NOM like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	SELECT NOM
	FROM CLIENT
	WHERE PAYS =
			(SELECT CODE
				FROM PAYS
				WHERE NOM = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	SELECT ID
	FROM RESERVATION
	WHERE ID in
			(SELECT ID
				FROM CLIENT
				WHERE (PRENOM = 'Jean'
											AND NOM = 'Dupont')
					OR (PRENOM = 'Marie'
									AND NOM = 'Durand'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes
	-- ayant eu lieu dans la ville de Paris ?
	
	SELECT SUM(DUREE)
	FROM ETAPE
	WHERE IDVILLE =
			(SELECT ID
				FROM VILLE
				WHERE NOM = 'Paris') ;
	
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des 
	-- voyages ayant eu lieu avant le 10/11/2015 ?
	 
	SELECT COUNT(*)
	FROM ETAPE 
	WHERE IDVOYAGE = 
			(SELECT ID
				FROM VOYAGE
				JOIN DEPART ON IDVOYAGE = ID 
				WHERE DATEDEPART < '10-11-2015')
				AND idVille = (SELECT ID
				FROM VILLE
				WHERE NOM = 'Paris') ;
	
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 20:05:16.028 UTC [12481] LOG:  statement: -- Questions
	-- 1)  Afficher la liste des voyages (nom appelé, type de voyage)
	
	SELECT NOM,
		TYPEVOYAGE
	FROM VOYAGE;
	
	-- 2)  Afficher (nom du vol, id vol) de tous les vols à destination de Paris
	
	SELECT NOM, ID
	FROM VOYAGE
	WHERE NOM like 'Paris%';
	
	-- 3)  Afficher le nom des personnes de nationalité Française
	
	SELECT NOM
	FROM CLIENT
	WHERE PAYS =
			(SELECT CODE
				FROM PAYS
				WHERE NOM = 'France');
	
	-- 4)  Afficher toutes les réservations de ‘Dupont Jean’ et ‘Durand Marie’
	
	SELECT ID
	FROM RESERVATION
	WHERE ID in
			(SELECT ID
				FROM CLIENT
				WHERE (PRENOM = 'Jean'
											AND NOM = 'Dupont')
					OR (PRENOM = 'Marie'
									AND NOM = 'Durand'));
	
	-- 5)  Afficher combien de temps ont duré au total les étapes
	-- ayant eu lieu dans la ville de Paris ?
	
	SELECT SUM(DUREE)
	FROM ETAPE
	WHERE IDVILLE =
			(SELECT ID
				FROM VILLE
				WHERE NOM = 'Paris') ;
	
	-- 6)  Afficher combien d'étapes ont eu lieu à Paris pour des 
	-- voyages ayant eu lieu avant le 10/11/2015 ?
	 
	SELECT COUNT(*)
	FROM ETAPE 
	WHERE IDVOYAGE in 
			(SELECT ID
				FROM VOYAGE
				JOIN DEPART ON IDVOYAGE = ID 
				WHERE DATEDEPART < '10-11-2015')
				AND idVille = (SELECT ID
				FROM VILLE
				WHERE NOM = 'Paris') ;
	
	-- 7)  Afficher tous les trajets dont la ville de départ est ‘Lyon’
	-- 8)  Afficher les adresses des clients qui ont participé à un vol avant ‘2015-09-01’
	-- 9)  Afficher les participants dont le prix de vol est inférieur ou égal à 300
	-- 10) Afficher le pays des participants à des vols partant de Paris en Aller Simple
	-- 11) Afficher le nom des villes Allemandes qui font partit d’un Aller-Retour
	-- 12) Afficher les vols qui ont 2 participants
	-- 13) Afficher le noms et prénom des voyageurs du dernier voyage reservé (datereservation) dans la table reservation
	-- 14) Afficher l'étape ayant duré le plus longtemps
	-- 15) Afficher les différents types de voyage
	-- 16) Afficher le pays et le nombre de villes différentes pour chacun des pays
	-- 17) Afficher le nom des voyageurs commençant par "A" ou "a" de la première réservation ayant eu une étape en France
	
2022-11-27 20:05:16.030 UTC [12481] LOG:  duration: 1.926 ms
2022-11-27 20:05:16.169 UTC [12481] LOG:  statement: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid IN (20) ORDER BY oid;
2022-11-27 20:05:16.169 UTC [12481] LOG:  duration: 0.475 ms
2022-11-27 20:13:31.137 UTC [17764] LOG:  connection received: host=::1 port=38170
2022-11-27 20:13:31.138 UTC [17764] LOG:  connection authorized: user=postgres database=postgres application_name=pgAdmin 4 - CONN:2503945
2022-11-27 20:13:31.139 UTC [17764] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='UNICODE';
2022-11-27 20:13:31.140 UTC [17764] LOG:  duration: 1.309 ms
2022-11-27 20:13:31.141 UTC [17764] LOG:  statement: SELECT version()
2022-11-27 20:13:31.141 UTC [17764] LOG:  duration: 0.098 ms
2022-11-27 20:13:31.141 UTC [17764] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2022-11-27 20:13:31.142 UTC [17764] LOG:  duration: 0.457 ms
2022-11-27 20:13:31.142 UTC [17764] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2022-11-27 20:13:31.142 UTC [17764] LOG:  duration: 0.374 ms
2022-11-27 20:13:31.143 UTC [17764] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2022-11-27 20:13:31.144 UTC [17764] LOG:  duration: 1.456 ms
2022-11-27 20:13:31.410 UTC [17764] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2022-11-27 20:13:31.423 UTC [17764] LOG:  duration: 13.330 ms
2022-11-27 20:13:31.477 UTC [17764] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	            nspname NOT LIKE 'pg!_%' escape '!' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2022-11-27 20:13:31.478 UTC [17764] LOG:  duration: 1.061 ms
2022-11-27 20:13:31.571 UTC [17764] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	            nspname NOT LIKE 'pg!_%' escape '!' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2022-11-27 20:13:31.572 UTC [17764] LOG:  duration: 0.552 ms
2022-11-27 20:13:31.613 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited
	FROM pg_catalog.pg_class rel
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	    AND NOT rel.relispartition
	        AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rel.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY rel.relname;
2022-11-27 20:13:31.628 UTC [17764] LOG:  duration: 15.030 ms
2022-11-27 20:13:31.640 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16426::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16426::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16464::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16464::oid ORDER BY rel.relname;
2022-11-27 20:13:31.656 UTC [17764] LOG:  duration: 15.700 ms
2022-11-27 20:13:31.691 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM ds.client;
2022-11-27 20:13:31.693 UTC [17764] LOG:  duration: 1.656 ms
2022-11-27 20:13:31.726 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16464::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16464::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:31.728 UTC [17764] LOG:  duration: 2.219 ms
2022-11-27 20:13:31.729 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16464::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16464::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:31.730 UTC [17764] LOG:  duration: 1.429 ms
2022-11-27 20:13:31.735 UTC [17764] LOG:  statement: SELECT name, setting::numeric AS setting FROM pg_catalog.pg_settings WHERE name IN('autovacuum_vacuum_threshold','autovacuum_analyze_threshold','autovacuum_vacuum_scale_factor','autovacuum_analyze_scale_factor','autovacuum_vacuum_cost_delay','autovacuum_vacuum_cost_limit','autovacuum_freeze_max_age','vacuum_freeze_min_age','vacuum_freeze_table_age') ORDER BY name
2022-11-27 20:13:31.736 UTC [17764] LOG:  duration: 1.034 ms
2022-11-27 20:13:31.737 UTC [17764] LOG:  statement: SELECT name, setting::numeric AS setting FROM pg_catalog.pg_settings WHERE name IN('autovacuum_vacuum_threshold','autovacuum_vacuum_scale_factor','autovacuum_vacuum_cost_delay','autovacuum_vacuum_cost_limit','autovacuum_freeze_max_age','vacuum_freeze_min_age','vacuum_freeze_table_age') ORDER BY name
2022-11-27 20:13:31.738 UTC [17764] LOG:  duration: 1.341 ms
2022-11-27 20:13:31.747 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16464::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:31.759 UTC [17764] LOG:  duration: 12.043 ms
2022-11-27 20:13:31.794 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:31.796 UTC [17764] LOG:  duration: 1.837 ms
2022-11-27 20:13:31.828 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:31.830 UTC [17764] LOG:  duration: 1.456 ms
2022-11-27 20:13:31.831 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:31.832 UTC [17764] LOG:  duration: 1.296 ms
2022-11-27 20:13:31.833 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:31.834 UTC [17764] LOG:  duration: 0.906 ms
2022-11-27 20:13:31.835 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:31.836 UTC [17764] LOG:  duration: 0.802 ms
2022-11-27 20:13:31.836 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:31.837 UTC [17764] LOG:  duration: 1.001 ms
2022-11-27 20:13:31.838 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16464::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:31.839 UTC [17764] LOG:  duration: 0.826 ms
2022-11-27 20:13:31.850 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16464::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:31.855 UTC [17764] LOG:  duration: 4.656 ms
2022-11-27 20:13:31.890 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16467 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:31.890 UTC [17764] LOG:  duration: 0.260 ms
2022-11-27 20:13:31.899 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16467::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:31.901 UTC [17764] LOG:  duration: 1.243 ms
2022-11-27 20:13:31.902 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16464::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:31.904 UTC [17764] LOG:  duration: 2.619 ms
2022-11-27 20:13:31.935 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16464::oid
	ORDER BY conname
2022-11-27 20:13:31.936 UTC [17764] LOG:  duration: 1.124 ms
2022-11-27 20:13:31.969 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16464::oid
	    AND a1.attnum=6
	    AND a2.attrelid=16427::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:31.974 UTC [17764] LOG:  duration: 4.914 ms
2022-11-27 20:13:32.007 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16427::oid
2022-11-27 20:13:32.007 UTC [17764] LOG:  duration: 0.343 ms
2022-11-27 20:13:32.039 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16464::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16464::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16464::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16464::oid
	   AND conname IS NULL
2022-11-27 20:13:32.043 UTC [17764] LOG:  duration: 4.266 ms
2022-11-27 20:13:32.080 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16467 , 1 , true) AS column
	
2022-11-27 20:13:32.080 UTC [17764] LOG:  duration: 0.183 ms
2022-11-27 20:13:32.113 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16464::oid
	
2022-11-27 20:13:32.114 UTC [17764] LOG:  duration: 0.956 ms
2022-11-27 20:13:32.126 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16464::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.136 UTC [17764] LOG:  duration: 10.582 ms
2022-11-27 20:13:32.169 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16464::oid
2022-11-27 20:13:32.170 UTC [12445] LOG:  duration: 0.504 ms
2022-11-27 20:13:32.203 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16464::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.208 UTC [12445] LOG:  duration: 4.991 ms
2022-11-27 20:13:32.214 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16464
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.215 UTC [12445] LOG:  duration: 1.132 ms
2022-11-27 20:13:32.254 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16464::oid
2022-11-27 20:13:32.255 UTC [12445] LOG:  duration: 0.320 ms
2022-11-27 20:13:32.290 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16464::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.291 UTC [12445] LOG:  duration: 0.840 ms
2022-11-27 20:13:32.327 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16464::oid
2022-11-27 20:13:32.328 UTC [12445] LOG:  duration: 0.466 ms
2022-11-27 20:13:32.363 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16464
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.369 UTC [12445] LOG:  duration: 5.561 ms
2022-11-27 20:13:32.370 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16426::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16426::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16489::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16489::oid ORDER BY rel.relname;
2022-11-27 20:13:32.376 UTC [17764] LOG:  duration: 6.119 ms
2022-11-27 20:13:32.380 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM ds.depart;
2022-11-27 20:13:32.381 UTC [17764] LOG:  duration: 1.771 ms
2022-11-27 20:13:32.382 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16489::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16489::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.385 UTC [17764] LOG:  duration: 2.291 ms
2022-11-27 20:13:32.385 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16489::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16489::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.387 UTC [17764] LOG:  duration: 1.933 ms
2022-11-27 20:13:32.388 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16489::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:32.394 UTC [17764] LOG:  duration: 5.422 ms
2022-11-27 20:13:32.396 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1082)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1082)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:32.397 UTC [17764] LOG:  duration: 1.112 ms
2022-11-27 20:13:32.398 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16489::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16489::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.399 UTC [17764] LOG:  duration: 1.394 ms
2022-11-27 20:13:32.401 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16489::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16489::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.402 UTC [17764] LOG:  duration: 1.021 ms
2022-11-27 20:13:32.403 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16489::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16489::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.403 UTC [17764] LOG:  duration: 1.018 ms
2022-11-27 20:13:32.404 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16489::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:32.407 UTC [17764] LOG:  duration: 2.415 ms
2022-11-27 20:13:32.408 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16492 , 1 , true) AS column, 0 AS dummy
	UNION SELECT  pg_catalog.pg_get_indexdef(16492, 2, true) AS column, 1 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:32.408 UTC [17764] LOG:  duration: 0.299 ms
2022-11-27 20:13:32.409 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16492::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:32.410 UTC [17764] LOG:  duration: 0.611 ms
2022-11-27 20:13:32.410 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16489::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:32.413 UTC [17764] LOG:  duration: 2.408 ms
2022-11-27 20:13:32.414 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16489::oid
	ORDER BY conname
2022-11-27 20:13:32.415 UTC [17764] LOG:  duration: 1.359 ms
2022-11-27 20:13:32.417 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16489::oid
	    AND a1.attnum=1
	    AND a2.attrelid=16442::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:32.417 UTC [17764] LOG:  duration: 0.400 ms
2022-11-27 20:13:32.418 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16442::oid
2022-11-27 20:13:32.418 UTC [17764] LOG:  duration: 0.358 ms
2022-11-27 20:13:32.419 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16489::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16489::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16489::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16489::oid
	   AND conname IS NULL
2022-11-27 20:13:32.422 UTC [17764] LOG:  duration: 3.083 ms
2022-11-27 20:13:32.423 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16492 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16492, 2, true) AS column
	
2022-11-27 20:13:32.423 UTC [17764] LOG:  duration: 0.195 ms
2022-11-27 20:13:32.424 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16489::oid
	
2022-11-27 20:13:32.425 UTC [17764] LOG:  duration: 0.558 ms
2022-11-27 20:13:32.426 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16489::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.429 UTC [17764] LOG:  duration: 3.573 ms
2022-11-27 20:13:32.432 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16489::oid
2022-11-27 20:13:32.432 UTC [12445] LOG:  duration: 0.336 ms
2022-11-27 20:13:32.433 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16489::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.437 UTC [12445] LOG:  duration: 3.759 ms
2022-11-27 20:13:32.439 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16489
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.439 UTC [12445] LOG:  duration: 0.305 ms
2022-11-27 20:13:32.441 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16489::oid
2022-11-27 20:13:32.441 UTC [12445] LOG:  duration: 0.314 ms
2022-11-27 20:13:32.442 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16489::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.443 UTC [12445] LOG:  duration: 0.342 ms
2022-11-27 20:13:32.445 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16489::oid
2022-11-27 20:13:32.445 UTC [12445] LOG:  duration: 0.309 ms
2022-11-27 20:13:32.446 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16489
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.446 UTC [12445] LOG:  duration: 0.286 ms
2022-11-27 20:13:32.447 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16426::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16426::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16449::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16449::oid ORDER BY rel.relname;
2022-11-27 20:13:32.452 UTC [17764] LOG:  duration: 5.650 ms
2022-11-27 20:13:32.456 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM ds.etape;
2022-11-27 20:13:32.456 UTC [17764] LOG:  duration: 0.647 ms
2022-11-27 20:13:32.457 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16449::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16449::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.459 UTC [17764] LOG:  duration: 1.536 ms
2022-11-27 20:13:32.460 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16449::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16449::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.461 UTC [17764] LOG:  duration: 1.407 ms
2022-11-27 20:13:32.462 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16449::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:32.468 UTC [17764] LOG:  duration: 5.631 ms
2022-11-27 20:13:32.469 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:32.470 UTC [17764] LOG:  duration: 0.840 ms
2022-11-27 20:13:32.471 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16449::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16449::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.472 UTC [17764] LOG:  duration: 0.913 ms
2022-11-27 20:13:32.473 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16449::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16449::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.474 UTC [17764] LOG:  duration: 0.916 ms
2022-11-27 20:13:32.475 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16449::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16449::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.475 UTC [17764] LOG:  duration: 0.891 ms
2022-11-27 20:13:32.476 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16449::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16449::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.477 UTC [17764] LOG:  duration: 0.896 ms
2022-11-27 20:13:32.478 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16449::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:32.480 UTC [17764] LOG:  duration: 2.494 ms
2022-11-27 20:13:32.481 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16452 , 1 , true) AS column, 0 AS dummy
	UNION SELECT  pg_catalog.pg_get_indexdef(16452, 2, true) AS column, 1 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:32.482 UTC [17764] LOG:  duration: 0.385 ms
2022-11-27 20:13:32.483 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16452::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:32.483 UTC [17764] LOG:  duration: 0.577 ms
2022-11-27 20:13:32.484 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16449::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:32.487 UTC [17764] LOG:  duration: 2.541 ms
2022-11-27 20:13:32.488 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16449::oid
	ORDER BY conname
2022-11-27 20:13:32.489 UTC [17764] LOG:  duration: 1.048 ms
2022-11-27 20:13:32.490 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16449::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16432::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:32.490 UTC [17764] LOG:  duration: 0.299 ms
2022-11-27 20:13:32.491 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16432::oid
2022-11-27 20:13:32.492 UTC [17764] LOG:  duration: 0.365 ms
2022-11-27 20:13:32.493 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16449::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16449::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16449::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16449::oid
	   AND conname IS NULL
2022-11-27 20:13:32.496 UTC [17764] LOG:  duration: 3.109 ms
2022-11-27 20:13:32.496 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16452 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16452, 2, true) AS column
	
2022-11-27 20:13:32.497 UTC [17764] LOG:  duration: 0.212 ms
2022-11-27 20:13:32.498 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16449::oid
	    AND a1.attnum=1
	    AND a2.attrelid=16442::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:32.498 UTC [17764] LOG:  duration: 0.291 ms
2022-11-27 20:13:32.499 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16442::oid
2022-11-27 20:13:32.499 UTC [17764] LOG:  duration: 0.294 ms
2022-11-27 20:13:32.500 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16449::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16449::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16449::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16449::oid
	   AND conname IS NULL
2022-11-27 20:13:32.503 UTC [17764] LOG:  duration: 3.201 ms
2022-11-27 20:13:32.505 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16452 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16452, 2, true) AS column
	
2022-11-27 20:13:32.505 UTC [17764] LOG:  duration: 0.195 ms
2022-11-27 20:13:32.505 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16449::oid
	
2022-11-27 20:13:32.506 UTC [17764] LOG:  duration: 0.564 ms
2022-11-27 20:13:32.507 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16449::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.510 UTC [17764] LOG:  duration: 3.759 ms
2022-11-27 20:13:32.514 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16449::oid
2022-11-27 20:13:32.514 UTC [12445] LOG:  duration: 0.529 ms
2022-11-27 20:13:32.515 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16449::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.518 UTC [12445] LOG:  duration: 2.993 ms
2022-11-27 20:13:32.520 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16449
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.521 UTC [12445] LOG:  duration: 0.340 ms
2022-11-27 20:13:32.523 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16449::oid
2022-11-27 20:13:32.523 UTC [12445] LOG:  duration: 0.446 ms
2022-11-27 20:13:32.524 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16449::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.524 UTC [12445] LOG:  duration: 0.324 ms
2022-11-27 20:13:32.526 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16449::oid
2022-11-27 20:13:32.527 UTC [12445] LOG:  duration: 0.470 ms
2022-11-27 20:13:32.528 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16449
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.528 UTC [12445] LOG:  duration: 0.316 ms
2022-11-27 20:13:32.529 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16426::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16426::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16427::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16427::oid ORDER BY rel.relname;
2022-11-27 20:13:32.534 UTC [17764] LOG:  duration: 5.317 ms
2022-11-27 20:13:32.538 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM ds.pays;
2022-11-27 20:13:32.538 UTC [17764] LOG:  duration: 0.870 ms
2022-11-27 20:13:32.539 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16427::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16427::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.541 UTC [17764] LOG:  duration: 1.471 ms
2022-11-27 20:13:32.541 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16427::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16427::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.543 UTC [17764] LOG:  duration: 1.486 ms
2022-11-27 20:13:32.544 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16427::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:32.549 UTC [17764] LOG:  duration: 5.561 ms
2022-11-27 20:13:32.551 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1042,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1042,1043)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:32.551 UTC [17764] LOG:  duration: 0.762 ms
2022-11-27 20:13:32.553 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16427::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16427::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.553 UTC [17764] LOG:  duration: 0.833 ms
2022-11-27 20:13:32.554 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16427::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16427::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.555 UTC [17764] LOG:  duration: 0.784 ms
2022-11-27 20:13:32.556 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16427::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:32.558 UTC [17764] LOG:  duration: 2.370 ms
2022-11-27 20:13:32.559 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16430 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:32.560 UTC [17764] LOG:  duration: 0.225 ms
2022-11-27 20:13:32.560 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16430::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:32.561 UTC [17764] LOG:  duration: 0.527 ms
2022-11-27 20:13:32.562 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16427::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:32.564 UTC [17764] LOG:  duration: 2.446 ms
2022-11-27 20:13:32.565 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16427::oid
	ORDER BY conname
2022-11-27 20:13:32.566 UTC [17764] LOG:  duration: 1.045 ms
2022-11-27 20:13:32.567 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16427::oid
	
2022-11-27 20:13:32.568 UTC [17764] LOG:  duration: 0.623 ms
2022-11-27 20:13:32.569 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16427::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.572 UTC [17764] LOG:  duration: 3.877 ms
2022-11-27 20:13:32.575 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16427::oid
2022-11-27 20:13:32.575 UTC [12445] LOG:  duration: 0.331 ms
2022-11-27 20:13:32.576 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16427::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.579 UTC [12445] LOG:  duration: 2.951 ms
2022-11-27 20:13:32.581 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16427
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.581 UTC [12445] LOG:  duration: 0.309 ms
2022-11-27 20:13:32.583 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16427::oid
2022-11-27 20:13:32.584 UTC [12445] LOG:  duration: 0.324 ms
2022-11-27 20:13:32.584 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16427::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.585 UTC [12445] LOG:  duration: 0.329 ms
2022-11-27 20:13:32.587 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16427::oid
2022-11-27 20:13:32.587 UTC [12445] LOG:  duration: 0.310 ms
2022-11-27 20:13:32.588 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16427
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.588 UTC [12445] LOG:  duration: 0.296 ms
2022-11-27 20:13:32.590 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16426::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16426::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16474::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16474::oid ORDER BY rel.relname;
2022-11-27 20:13:32.594 UTC [17764] LOG:  duration: 4.882 ms
2022-11-27 20:13:32.597 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM ds.reservation;
2022-11-27 20:13:32.598 UTC [17764] LOG:  duration: 1.118 ms
2022-11-27 20:13:32.599 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16474::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16474::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.601 UTC [17764] LOG:  duration: 1.696 ms
2022-11-27 20:13:32.602 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16474::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16474::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.603 UTC [17764] LOG:  duration: 1.636 ms
2022-11-27 20:13:32.604 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16474::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:32.610 UTC [17764] LOG:  duration: 5.778 ms
2022-11-27 20:13:32.612 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1082)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1082)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:32.613 UTC [17764] LOG:  duration: 0.822 ms
2022-11-27 20:13:32.614 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.614 UTC [17764] LOG:  duration: 0.839 ms
2022-11-27 20:13:32.615 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.616 UTC [17764] LOG:  duration: 0.866 ms
2022-11-27 20:13:32.617 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.618 UTC [17764] LOG:  duration: 0.819 ms
2022-11-27 20:13:32.619 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.620 UTC [17764] LOG:  duration: 0.888 ms
2022-11-27 20:13:32.620 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.621 UTC [17764] LOG:  duration: 0.832 ms
2022-11-27 20:13:32.622 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.623 UTC [17764] LOG:  duration: 0.958 ms
2022-11-27 20:13:32.624 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 7::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16474::oid
	        AND att.attnum = 7::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.625 UTC [17764] LOG:  duration: 0.921 ms
2022-11-27 20:13:32.626 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16474::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:32.628 UTC [17764] LOG:  duration: 2.639 ms
2022-11-27 20:13:32.629 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16477 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:32.630 UTC [17764] LOG:  duration: 0.289 ms
2022-11-27 20:13:32.631 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16477::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:32.631 UTC [17764] LOG:  duration: 0.626 ms
2022-11-27 20:13:32.632 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16474::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:32.635 UTC [17764] LOG:  duration: 2.731 ms
2022-11-27 20:13:32.636 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16474::oid
	ORDER BY conname
2022-11-27 20:13:32.637 UTC [17764] LOG:  duration: 1.042 ms
2022-11-27 20:13:32.638 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16474::oid
	    AND a1.attnum=7
	    AND a2.attrelid=16464::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:32.639 UTC [17764] LOG:  duration: 0.338 ms
2022-11-27 20:13:32.639 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16464::oid
2022-11-27 20:13:32.640 UTC [17764] LOG:  duration: 0.392 ms
2022-11-27 20:13:32.641 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16474::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16474::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16474::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16474::oid
	   AND conname IS NULL
2022-11-27 20:13:32.644 UTC [17764] LOG:  duration: 3.081 ms
2022-11-27 20:13:32.645 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16477 , 1 , true) AS column
	
2022-11-27 20:13:32.645 UTC [17764] LOG:  duration: 0.134 ms
2022-11-27 20:13:32.645 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16474::oid
	    AND a1.attnum=4
	    AND a2.attrelid=16442::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:32.646 UTC [17764] LOG:  duration: 0.246 ms
2022-11-27 20:13:32.646 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16442::oid
2022-11-27 20:13:32.647 UTC [17764] LOG:  duration: 0.299 ms
2022-11-27 20:13:32.648 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16474::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16474::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16474::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16474::oid
	   AND conname IS NULL
2022-11-27 20:13:32.651 UTC [17764] LOG:  duration: 3.401 ms
2022-11-27 20:13:32.652 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16477 , 1 , true) AS column
	
2022-11-27 20:13:32.652 UTC [17764] LOG:  duration: 0.179 ms
2022-11-27 20:13:32.653 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16474::oid
	
2022-11-27 20:13:32.654 UTC [17764] LOG:  duration: 0.587 ms
2022-11-27 20:13:32.654 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16474::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.658 UTC [17764] LOG:  duration: 3.654 ms
2022-11-27 20:13:32.661 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16474::oid
2022-11-27 20:13:32.661 UTC [12445] LOG:  duration: 0.321 ms
2022-11-27 20:13:32.662 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16474::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.665 UTC [12445] LOG:  duration: 2.821 ms
2022-11-27 20:13:32.667 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16474
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.668 UTC [12445] LOG:  duration: 0.335 ms
2022-11-27 20:13:32.670 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16474::oid
2022-11-27 20:13:32.670 UTC [12445] LOG:  duration: 0.398 ms
2022-11-27 20:13:32.671 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16474::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.671 UTC [12445] LOG:  duration: 0.313 ms
2022-11-27 20:13:32.673 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16474::oid
2022-11-27 20:13:32.673 UTC [12445] LOG:  duration: 0.312 ms
2022-11-27 20:13:32.674 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16474
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.675 UTC [12445] LOG:  duration: 0.295 ms
2022-11-27 20:13:32.676 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16426::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16426::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16432::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16432::oid ORDER BY rel.relname;
2022-11-27 20:13:32.681 UTC [17764] LOG:  duration: 5.232 ms
2022-11-27 20:13:32.684 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM ds.ville;
2022-11-27 20:13:32.685 UTC [17764] LOG:  duration: 1.255 ms
2022-11-27 20:13:32.686 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16432::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16432::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.687 UTC [17764] LOG:  duration: 1.494 ms
2022-11-27 20:13:32.689 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16432::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16432::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.690 UTC [17764] LOG:  duration: 1.546 ms
2022-11-27 20:13:32.692 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16432::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:32.697 UTC [17764] LOG:  duration: 5.736 ms
2022-11-27 20:13:32.699 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:32.700 UTC [17764] LOG:  duration: 0.858 ms
2022-11-27 20:13:32.701 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16432::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16432::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.702 UTC [17764] LOG:  duration: 1.048 ms
2022-11-27 20:13:32.703 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16432::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16432::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.704 UTC [17764] LOG:  duration: 0.831 ms
2022-11-27 20:13:32.705 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16432::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16432::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.706 UTC [17764] LOG:  duration: 0.817 ms
2022-11-27 20:13:32.707 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16432::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:32.709 UTC [17764] LOG:  duration: 2.375 ms
2022-11-27 20:13:32.711 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16435 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:32.711 UTC [17764] LOG:  duration: 0.211 ms
2022-11-27 20:13:32.711 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16435::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:32.712 UTC [17764] LOG:  duration: 0.499 ms
2022-11-27 20:13:32.713 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16432::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:32.715 UTC [17764] LOG:  duration: 2.474 ms
2022-11-27 20:13:32.716 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16432::oid
	ORDER BY conname
2022-11-27 20:13:32.717 UTC [17764] LOG:  duration: 0.991 ms
2022-11-27 20:13:32.718 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16432::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16427::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:32.719 UTC [17764] LOG:  duration: 0.405 ms
2022-11-27 20:13:32.720 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16427::oid
2022-11-27 20:13:32.720 UTC [17764] LOG:  duration: 0.382 ms
2022-11-27 20:13:32.721 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16432::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16432::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16432::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16432::oid
	   AND conname IS NULL
2022-11-27 20:13:32.724 UTC [17764] LOG:  duration: 3.041 ms
2022-11-27 20:13:32.725 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16435 , 1 , true) AS column
	
2022-11-27 20:13:32.725 UTC [17764] LOG:  duration: 0.168 ms
2022-11-27 20:13:32.726 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16432::oid
	
2022-11-27 20:13:32.726 UTC [17764] LOG:  duration: 0.632 ms
2022-11-27 20:13:32.727 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16432::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.730 UTC [17764] LOG:  duration: 3.658 ms
2022-11-27 20:13:32.733 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16432::oid
2022-11-27 20:13:32.734 UTC [12445] LOG:  duration: 0.351 ms
2022-11-27 20:13:32.735 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16432::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.738 UTC [12445] LOG:  duration: 3.030 ms
2022-11-27 20:13:32.740 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16432
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.740 UTC [12445] LOG:  duration: 0.310 ms
2022-11-27 20:13:32.742 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16432::oid
2022-11-27 20:13:32.742 UTC [12445] LOG:  duration: 0.316 ms
2022-11-27 20:13:32.743 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16432::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.743 UTC [12445] LOG:  duration: 0.304 ms
2022-11-27 20:13:32.745 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16432::oid
2022-11-27 20:13:32.746 UTC [12445] LOG:  duration: 0.325 ms
2022-11-27 20:13:32.747 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16432
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.747 UTC [12445] LOG:  duration: 0.278 ms
2022-11-27 20:13:32.748 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16426::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16426::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16442::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16442::oid ORDER BY rel.relname;
2022-11-27 20:13:32.754 UTC [17764] LOG:  duration: 6.062 ms
2022-11-27 20:13:32.757 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM ds.voyage;
2022-11-27 20:13:32.758 UTC [17764] LOG:  duration: 1.266 ms
2022-11-27 20:13:32.760 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16442::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16442::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.761 UTC [17764] LOG:  duration: 1.637 ms
2022-11-27 20:13:32.762 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16442::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16426::oid
	            AND rel.oid = 16442::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.764 UTC [17764] LOG:  duration: 1.804 ms
2022-11-27 20:13:32.765 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16442::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:32.771 UTC [17764] LOG:  duration: 6.014 ms
2022-11-27 20:13:32.773 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042,1700)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:32.774 UTC [17764] LOG:  duration: 1.270 ms
2022-11-27 20:13:32.776 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16442::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16442::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.777 UTC [17764] LOG:  duration: 0.962 ms
2022-11-27 20:13:32.778 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16442::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16442::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.778 UTC [17764] LOG:  duration: 0.875 ms
2022-11-27 20:13:32.779 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16442::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16442::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.780 UTC [17764] LOG:  duration: 0.996 ms
2022-11-27 20:13:32.782 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16442::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16442::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.783 UTC [17764] LOG:  duration: 0.958 ms
2022-11-27 20:13:32.784 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16442::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:32.786 UTC [17764] LOG:  duration: 2.852 ms
2022-11-27 20:13:32.787 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16447 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:32.787 UTC [17764] LOG:  duration: 0.182 ms
2022-11-27 20:13:32.788 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16447::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:32.789 UTC [17764] LOG:  duration: 0.623 ms
2022-11-27 20:13:32.789 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16442::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:32.792 UTC [17764] LOG:  duration: 2.487 ms
2022-11-27 20:13:32.793 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16442::oid
	ORDER BY conname
2022-11-27 20:13:32.794 UTC [17764] LOG:  duration: 1.160 ms
2022-11-27 20:13:32.795 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16442::oid
	
2022-11-27 20:13:32.796 UTC [17764] LOG:  duration: 0.615 ms
2022-11-27 20:13:32.797 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16442::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.801 UTC [17764] LOG:  duration: 4.162 ms
2022-11-27 20:13:32.804 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16442::oid
2022-11-27 20:13:32.804 UTC [12445] LOG:  duration: 0.328 ms
2022-11-27 20:13:32.805 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16442::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.808 UTC [12445] LOG:  duration: 2.842 ms
2022-11-27 20:13:32.810 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16442
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.810 UTC [12445] LOG:  duration: 0.304 ms
2022-11-27 20:13:32.812 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16442::oid
2022-11-27 20:13:32.812 UTC [12445] LOG:  duration: 0.305 ms
2022-11-27 20:13:32.813 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16442::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.813 UTC [12445] LOG:  duration: 0.301 ms
2022-11-27 20:13:32.816 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16442::oid
2022-11-27 20:13:32.816 UTC [12445] LOG:  duration: 0.320 ms
2022-11-27 20:13:32.817 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16442
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.817 UTC [12445] LOG:  duration: 0.288 ms
2022-11-27 20:13:32.818 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited
	FROM pg_catalog.pg_class rel
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	    AND NOT rel.relispartition
	        AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rel.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY rel.relname;
2022-11-27 20:13:32.825 UTC [17764] LOG:  duration: 7.330 ms
2022-11-27 20:13:32.827 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16870::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16870::oid ORDER BY rel.relname;
2022-11-27 20:13:32.832 UTC [17764] LOG:  duration: 5.853 ms
2022-11-27 20:13:32.836 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM public.client;
2022-11-27 20:13:32.836 UTC [17764] LOG:  duration: 0.448 ms
2022-11-27 20:13:32.837 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16870::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16870::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.839 UTC [17764] LOG:  duration: 1.809 ms
2022-11-27 20:13:32.840 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16870::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16870::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.842 UTC [17764] LOG:  duration: 1.676 ms
2022-11-27 20:13:32.843 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16870::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:32.849 UTC [17764] LOG:  duration: 6.004 ms
2022-11-27 20:13:32.852 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:32.853 UTC [17764] LOG:  duration: 1.200 ms
2022-11-27 20:13:32.854 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.855 UTC [17764] LOG:  duration: 0.955 ms
2022-11-27 20:13:32.856 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.857 UTC [17764] LOG:  duration: 0.981 ms
2022-11-27 20:13:32.858 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.858 UTC [17764] LOG:  duration: 0.891 ms
2022-11-27 20:13:32.860 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.860 UTC [17764] LOG:  duration: 0.897 ms
2022-11-27 20:13:32.861 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.862 UTC [17764] LOG:  duration: 0.908 ms
2022-11-27 20:13:32.863 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.864 UTC [17764] LOG:  duration: 0.889 ms
2022-11-27 20:13:32.865 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16870::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:32.868 UTC [17764] LOG:  duration: 2.691 ms
2022-11-27 20:13:32.869 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16873 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:32.870 UTC [17764] LOG:  duration: 0.271 ms
2022-11-27 20:13:32.871 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16873::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:32.871 UTC [17764] LOG:  duration: 0.580 ms
2022-11-27 20:13:32.872 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16870::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:32.875 UTC [17764] LOG:  duration: 2.647 ms
2022-11-27 20:13:32.876 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16870::oid
	ORDER BY conname
2022-11-27 20:13:32.877 UTC [17764] LOG:  duration: 1.175 ms
2022-11-27 20:13:32.878 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16870::oid
	    AND a1.attnum=6
	    AND a2.attrelid=16833::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:32.879 UTC [17764] LOG:  duration: 0.396 ms
2022-11-27 20:13:32.880 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16833::oid
2022-11-27 20:13:32.880 UTC [17764] LOG:  duration: 0.418 ms
2022-11-27 20:13:32.881 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16870::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16870::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16870::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16870::oid
	   AND conname IS NULL
2022-11-27 20:13:32.884 UTC [17764] LOG:  duration: 3.271 ms
2022-11-27 20:13:32.885 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16873 , 1 , true) AS column
	
2022-11-27 20:13:32.885 UTC [17764] LOG:  duration: 0.194 ms
2022-11-27 20:13:32.886 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16870::oid
	
2022-11-27 20:13:32.887 UTC [17764] LOG:  duration: 0.664 ms
2022-11-27 20:13:32.888 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16870::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.892 UTC [17764] LOG:  duration: 3.632 ms
2022-11-27 20:13:32.895 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16870::oid
2022-11-27 20:13:32.895 UTC [12445] LOG:  duration: 0.336 ms
2022-11-27 20:13:32.896 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16870::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.898 UTC [12445] LOG:  duration: 2.829 ms
2022-11-27 20:13:32.901 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16870
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.901 UTC [12445] LOG:  duration: 0.316 ms
2022-11-27 20:13:32.903 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16870::oid
2022-11-27 20:13:32.903 UTC [12445] LOG:  duration: 0.312 ms
2022-11-27 20:13:32.904 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16870::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.905 UTC [12445] LOG:  duration: 0.328 ms
2022-11-27 20:13:32.906 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16870::oid
2022-11-27 20:13:32.907 UTC [12445] LOG:  duration: 0.331 ms
2022-11-27 20:13:32.908 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16870
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.908 UTC [12445] LOG:  duration: 0.298 ms
2022-11-27 20:13:32.909 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16895::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16895::oid ORDER BY rel.relname;
2022-11-27 20:13:32.914 UTC [17764] LOG:  duration: 5.409 ms
2022-11-27 20:13:32.918 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM public.depart;
2022-11-27 20:13:32.918 UTC [17764] LOG:  duration: 0.454 ms
2022-11-27 20:13:32.919 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16895::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16895::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.921 UTC [17764] LOG:  duration: 1.521 ms
2022-11-27 20:13:32.922 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16895::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16895::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.923 UTC [17764] LOG:  duration: 1.485 ms
2022-11-27 20:13:32.924 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16895::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:32.930 UTC [17764] LOG:  duration: 5.614 ms
2022-11-27 20:13:32.932 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1082)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1082)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:32.933 UTC [17764] LOG:  duration: 0.892 ms
2022-11-27 20:13:32.934 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.935 UTC [17764] LOG:  duration: 0.845 ms
2022-11-27 20:13:32.936 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.937 UTC [17764] LOG:  duration: 0.786 ms
2022-11-27 20:13:32.938 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.939 UTC [17764] LOG:  duration: 0.870 ms
2022-11-27 20:13:32.940 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16895::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:32.942 UTC [17764] LOG:  duration: 2.408 ms
2022-11-27 20:13:32.943 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16898 , 1 , true) AS column, 0 AS dummy
	UNION SELECT  pg_catalog.pg_get_indexdef(16898, 2, true) AS column, 1 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:32.943 UTC [17764] LOG:  duration: 0.314 ms
2022-11-27 20:13:32.944 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16898::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:32.945 UTC [17764] LOG:  duration: 0.529 ms
2022-11-27 20:13:32.946 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16895::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:32.948 UTC [17764] LOG:  duration: 2.531 ms
2022-11-27 20:13:32.949 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16895::oid
	ORDER BY conname
2022-11-27 20:13:32.950 UTC [17764] LOG:  duration: 1.170 ms
2022-11-27 20:13:32.952 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16895::oid
	    AND a1.attnum=1
	    AND a2.attrelid=16848::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:32.952 UTC [17764] LOG:  duration: 0.425 ms
2022-11-27 20:13:32.953 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16848::oid
2022-11-27 20:13:32.953 UTC [17764] LOG:  duration: 0.326 ms
2022-11-27 20:13:32.954 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16895::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16895::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16895::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16895::oid
	   AND conname IS NULL
2022-11-27 20:13:32.957 UTC [17764] LOG:  duration: 3.158 ms
2022-11-27 20:13:32.958 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16898 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16898, 2, true) AS column
	
2022-11-27 20:13:32.959 UTC [17764] LOG:  duration: 0.245 ms
2022-11-27 20:13:32.959 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16895::oid
	
2022-11-27 20:13:32.960 UTC [17764] LOG:  duration: 0.578 ms
2022-11-27 20:13:32.961 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16895::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:32.965 UTC [17764] LOG:  duration: 3.999 ms
2022-11-27 20:13:32.967 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16895::oid
2022-11-27 20:13:32.968 UTC [12445] LOG:  duration: 0.422 ms
2022-11-27 20:13:32.969 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16895::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:32.972 UTC [12445] LOG:  duration: 3.215 ms
2022-11-27 20:13:32.974 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16895
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:32.975 UTC [12445] LOG:  duration: 0.389 ms
2022-11-27 20:13:32.977 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16895::oid
2022-11-27 20:13:32.977 UTC [12445] LOG:  duration: 0.309 ms
2022-11-27 20:13:32.978 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16895::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:32.978 UTC [12445] LOG:  duration: 0.366 ms
2022-11-27 20:13:32.980 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16895::oid
2022-11-27 20:13:32.980 UTC [12445] LOG:  duration: 0.328 ms
2022-11-27 20:13:32.981 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16895
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:32.982 UTC [12445] LOG:  duration: 0.355 ms
2022-11-27 20:13:32.983 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16855::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16855::oid ORDER BY rel.relname;
2022-11-27 20:13:32.988 UTC [17764] LOG:  duration: 5.327 ms
2022-11-27 20:13:32.991 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM public.etape;
2022-11-27 20:13:32.991 UTC [17764] LOG:  duration: 0.348 ms
2022-11-27 20:13:32.992 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16855::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16855::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.994 UTC [17764] LOG:  duration: 1.941 ms
2022-11-27 20:13:32.995 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16855::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16855::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:32.996 UTC [17764] LOG:  duration: 1.479 ms
2022-11-27 20:13:32.998 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16855::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:33.004 UTC [17764] LOG:  duration: 5.792 ms
2022-11-27 20:13:33.006 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:33.006 UTC [17764] LOG:  duration: 0.713 ms
2022-11-27 20:13:33.008 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.008 UTC [17764] LOG:  duration: 1.052 ms
2022-11-27 20:13:33.009 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.010 UTC [17764] LOG:  duration: 0.892 ms
2022-11-27 20:13:33.011 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.012 UTC [17764] LOG:  duration: 0.936 ms
2022-11-27 20:13:33.013 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.014 UTC [17764] LOG:  duration: 0.851 ms
2022-11-27 20:13:33.015 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16855::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:33.017 UTC [17764] LOG:  duration: 2.590 ms
2022-11-27 20:13:33.018 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16858 , 1 , true) AS column, 0 AS dummy
	UNION SELECT  pg_catalog.pg_get_indexdef(16858, 2, true) AS column, 1 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:33.019 UTC [17764] LOG:  duration: 0.294 ms
2022-11-27 20:13:33.019 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16858::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:33.020 UTC [17764] LOG:  duration: 0.532 ms
2022-11-27 20:13:33.021 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16855::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:33.023 UTC [17764] LOG:  duration: 2.547 ms
2022-11-27 20:13:33.024 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16855::oid
	ORDER BY conname
2022-11-27 20:13:33.025 UTC [17764] LOG:  duration: 0.991 ms
2022-11-27 20:13:33.026 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16855::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16838::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:33.027 UTC [17764] LOG:  duration: 0.317 ms
2022-11-27 20:13:33.027 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16838::oid
2022-11-27 20:13:33.028 UTC [17764] LOG:  duration: 0.271 ms
2022-11-27 20:13:33.028 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	   AND conname IS NULL
2022-11-27 20:13:33.031 UTC [17764] LOG:  duration: 3.265 ms
2022-11-27 20:13:33.033 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16858 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16858, 2, true) AS column
	
2022-11-27 20:13:33.033 UTC [17764] LOG:  duration: 0.215 ms
2022-11-27 20:13:33.034 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16855::oid
	    AND a1.attnum=1
	    AND a2.attrelid=16848::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:33.035 UTC [17764] LOG:  duration: 0.400 ms
2022-11-27 20:13:33.036 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16848::oid
2022-11-27 20:13:33.036 UTC [17764] LOG:  duration: 0.322 ms
2022-11-27 20:13:33.037 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	   AND conname IS NULL
2022-11-27 20:13:33.040 UTC [17764] LOG:  duration: 2.934 ms
2022-11-27 20:13:33.041 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16858 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16858, 2, true) AS column
	
2022-11-27 20:13:33.041 UTC [17764] LOG:  duration: 0.208 ms
2022-11-27 20:13:33.042 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16855::oid
	
2022-11-27 20:13:33.043 UTC [17764] LOG:  duration: 0.617 ms
2022-11-27 20:13:33.044 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16855::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:33.048 UTC [17764] LOG:  duration: 4.108 ms
2022-11-27 20:13:33.051 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16855::oid
2022-11-27 20:13:33.052 UTC [12445] LOG:  duration: 0.515 ms
2022-11-27 20:13:33.053 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16855::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:33.056 UTC [12445] LOG:  duration: 2.864 ms
2022-11-27 20:13:33.058 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16855
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:33.059 UTC [12445] LOG:  duration: 0.417 ms
2022-11-27 20:13:33.061 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16855::oid
2022-11-27 20:13:33.061 UTC [12445] LOG:  duration: 0.308 ms
2022-11-27 20:13:33.062 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16855::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:33.062 UTC [12445] LOG:  duration: 0.297 ms
2022-11-27 20:13:33.064 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16855::oid
2022-11-27 20:13:33.065 UTC [12445] LOG:  duration: 0.336 ms
2022-11-27 20:13:33.065 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16855
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:33.066 UTC [12445] LOG:  duration: 0.303 ms
2022-11-27 20:13:33.067 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16833::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16833::oid ORDER BY rel.relname;
2022-11-27 20:13:33.072 UTC [17764] LOG:  duration: 5.201 ms
2022-11-27 20:13:33.075 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM public.pays;
2022-11-27 20:13:33.076 UTC [17764] LOG:  duration: 0.443 ms
2022-11-27 20:13:33.077 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16833::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16833::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.079 UTC [17764] LOG:  duration: 2.084 ms
2022-11-27 20:13:33.080 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16833::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16833::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.081 UTC [17764] LOG:  duration: 1.477 ms
2022-11-27 20:13:33.083 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16833::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:33.088 UTC [17764] LOG:  duration: 5.380 ms
2022-11-27 20:13:33.090 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1042,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1042,1043)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:33.091 UTC [17764] LOG:  duration: 0.684 ms
2022-11-27 20:13:33.092 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16833::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16833::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.092 UTC [17764] LOG:  duration: 1.025 ms
2022-11-27 20:13:33.093 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16833::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16833::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.094 UTC [17764] LOG:  duration: 0.814 ms
2022-11-27 20:13:33.095 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16833::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:33.098 UTC [17764] LOG:  duration: 2.658 ms
2022-11-27 20:13:33.099 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16836 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:33.099 UTC [17764] LOG:  duration: 0.188 ms
2022-11-27 20:13:33.100 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16836::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:33.100 UTC [17764] LOG:  duration: 0.475 ms
2022-11-27 20:13:33.101 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16833::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:33.104 UTC [17764] LOG:  duration: 2.662 ms
2022-11-27 20:13:33.105 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16833::oid
	ORDER BY conname
2022-11-27 20:13:33.106 UTC [17764] LOG:  duration: 1.085 ms
2022-11-27 20:13:33.107 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16833::oid
	
2022-11-27 20:13:33.108 UTC [17764] LOG:  duration: 0.638 ms
2022-11-27 20:13:33.109 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16833::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:33.112 UTC [17764] LOG:  duration: 3.677 ms
2022-11-27 20:13:33.115 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16833::oid
2022-11-27 20:13:33.116 UTC [12445] LOG:  duration: 0.329 ms
2022-11-27 20:13:33.117 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16833::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:33.120 UTC [12445] LOG:  duration: 3.308 ms
2022-11-27 20:13:33.122 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16833
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:33.122 UTC [12445] LOG:  duration: 0.336 ms
2022-11-27 20:13:33.124 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16833::oid
2022-11-27 20:13:33.124 UTC [12445] LOG:  duration: 0.309 ms
2022-11-27 20:13:33.125 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16833::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:33.126 UTC [12445] LOG:  duration: 0.434 ms
2022-11-27 20:13:33.128 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16833::oid
2022-11-27 20:13:33.128 UTC [12445] LOG:  duration: 0.296 ms
2022-11-27 20:13:33.129 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16833
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:33.129 UTC [12445] LOG:  duration: 0.399 ms
2022-11-27 20:13:33.130 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16880::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16880::oid ORDER BY rel.relname;
2022-11-27 20:13:33.135 UTC [17764] LOG:  duration: 5.152 ms
2022-11-27 20:13:33.138 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM public.reservation;
2022-11-27 20:13:33.139 UTC [17764] LOG:  duration: 0.468 ms
2022-11-27 20:13:33.140 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16880::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16880::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.141 UTC [17764] LOG:  duration: 1.680 ms
2022-11-27 20:13:33.142 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16880::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16880::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.144 UTC [17764] LOG:  duration: 1.489 ms
2022-11-27 20:13:33.145 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16880::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:33.151 UTC [17764] LOG:  duration: 5.846 ms
2022-11-27 20:13:33.153 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1082)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1082)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:33.154 UTC [17764] LOG:  duration: 0.791 ms
2022-11-27 20:13:33.155 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.156 UTC [17764] LOG:  duration: 0.867 ms
2022-11-27 20:13:33.157 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.158 UTC [17764] LOG:  duration: 0.743 ms
2022-11-27 20:13:33.158 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.159 UTC [17764] LOG:  duration: 0.805 ms
2022-11-27 20:13:33.160 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.161 UTC [17764] LOG:  duration: 0.764 ms
2022-11-27 20:13:33.162 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.162 UTC [17764] LOG:  duration: 0.710 ms
2022-11-27 20:13:33.164 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.164 UTC [17764] LOG:  duration: 0.934 ms
2022-11-27 20:13:33.165 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 7::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 7::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.166 UTC [17764] LOG:  duration: 0.898 ms
2022-11-27 20:13:33.167 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16880::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:33.170 UTC [17764] LOG:  duration: 2.755 ms
2022-11-27 20:13:33.171 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16883 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:33.171 UTC [17764] LOG:  duration: 0.217 ms
2022-11-27 20:13:33.172 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16883::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:33.173 UTC [17764] LOG:  duration: 0.709 ms
2022-11-27 20:13:33.174 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16880::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:33.176 UTC [17764] LOG:  duration: 2.394 ms
2022-11-27 20:13:33.177 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16880::oid
	ORDER BY conname
2022-11-27 20:13:33.178 UTC [17764] LOG:  duration: 1.030 ms
2022-11-27 20:13:33.179 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16880::oid
	    AND a1.attnum=7
	    AND a2.attrelid=16870::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:33.180 UTC [17764] LOG:  duration: 0.374 ms
2022-11-27 20:13:33.181 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16870::oid
2022-11-27 20:13:33.181 UTC [17764] LOG:  duration: 0.373 ms
2022-11-27 20:13:33.182 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	   AND conname IS NULL
2022-11-27 20:13:33.185 UTC [17764] LOG:  duration: 3.317 ms
2022-11-27 20:13:33.186 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16883 , 1 , true) AS column
	
2022-11-27 20:13:33.186 UTC [17764] LOG:  duration: 0.122 ms
2022-11-27 20:13:33.187 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16880::oid
	    AND a1.attnum=4
	    AND a2.attrelid=16848::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:33.187 UTC [17764] LOG:  duration: 0.236 ms
2022-11-27 20:13:33.188 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16848::oid
2022-11-27 20:13:33.188 UTC [17764] LOG:  duration: 0.276 ms
2022-11-27 20:13:33.189 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	   AND conname IS NULL
2022-11-27 20:13:33.191 UTC [17764] LOG:  duration: 2.803 ms
2022-11-27 20:13:33.193 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16883 , 1 , true) AS column
	
2022-11-27 20:13:33.193 UTC [17764] LOG:  duration: 0.114 ms
2022-11-27 20:13:33.194 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16880::oid
	
2022-11-27 20:13:33.194 UTC [17764] LOG:  duration: 0.517 ms
2022-11-27 20:13:33.195 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16880::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:33.199 UTC [17764] LOG:  duration: 3.840 ms
2022-11-27 20:13:33.202 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16880::oid
2022-11-27 20:13:33.202 UTC [12445] LOG:  duration: 0.307 ms
2022-11-27 20:13:33.203 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16880::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:33.206 UTC [12445] LOG:  duration: 3.127 ms
2022-11-27 20:13:33.209 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16880
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:33.209 UTC [12445] LOG:  duration: 0.312 ms
2022-11-27 20:13:33.211 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16880::oid
2022-11-27 20:13:33.211 UTC [12445] LOG:  duration: 0.306 ms
2022-11-27 20:13:33.212 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16880::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:33.212 UTC [12445] LOG:  duration: 0.348 ms
2022-11-27 20:13:33.215 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16880::oid
2022-11-27 20:13:33.215 UTC [12445] LOG:  duration: 0.334 ms
2022-11-27 20:13:33.216 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16880
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:33.216 UTC [12445] LOG:  duration: 0.305 ms
2022-11-27 20:13:33.217 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16838::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16838::oid ORDER BY rel.relname;
2022-11-27 20:13:33.223 UTC [17764] LOG:  duration: 5.464 ms
2022-11-27 20:13:33.226 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM public.ville;
2022-11-27 20:13:33.226 UTC [17764] LOG:  duration: 0.426 ms
2022-11-27 20:13:33.227 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16838::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16838::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.229 UTC [17764] LOG:  duration: 1.665 ms
2022-11-27 20:13:33.230 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16838::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16838::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.231 UTC [17764] LOG:  duration: 1.566 ms
2022-11-27 20:13:33.233 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16838::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:33.238 UTC [17764] LOG:  duration: 5.391 ms
2022-11-27 20:13:33.240 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:33.241 UTC [17764] LOG:  duration: 0.839 ms
2022-11-27 20:13:33.242 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.243 UTC [17764] LOG:  duration: 0.903 ms
2022-11-27 20:13:33.244 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.245 UTC [17764] LOG:  duration: 0.855 ms
2022-11-27 20:13:33.246 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.247 UTC [17764] LOG:  duration: 0.912 ms
2022-11-27 20:13:33.248 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16838::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:33.250 UTC [17764] LOG:  duration: 2.665 ms
2022-11-27 20:13:33.251 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16841 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:33.252 UTC [17764] LOG:  duration: 0.293 ms
2022-11-27 20:13:33.252 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16841::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:33.253 UTC [17764] LOG:  duration: 0.591 ms
2022-11-27 20:13:33.254 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16838::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:33.256 UTC [17764] LOG:  duration: 2.419 ms
2022-11-27 20:13:33.257 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16838::oid
	ORDER BY conname
2022-11-27 20:13:33.258 UTC [17764] LOG:  duration: 0.994 ms
2022-11-27 20:13:33.259 UTC [17764] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16838::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16833::oid
	    AND a2.attnum=1
	
2022-11-27 20:13:33.259 UTC [17764] LOG:  duration: 0.301 ms
2022-11-27 20:13:33.260 UTC [17764] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16833::oid
2022-11-27 20:13:33.261 UTC [17764] LOG:  duration: 0.322 ms
2022-11-27 20:13:33.262 UTC [17764] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16838::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16838::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16838::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16838::oid
	   AND conname IS NULL
2022-11-27 20:13:33.265 UTC [17764] LOG:  duration: 3.393 ms
2022-11-27 20:13:33.266 UTC [17764] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16841 , 1 , true) AS column
	
2022-11-27 20:13:33.266 UTC [17764] LOG:  duration: 0.177 ms
2022-11-27 20:13:33.267 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16838::oid
	
2022-11-27 20:13:33.267 UTC [17764] LOG:  duration: 0.618 ms
2022-11-27 20:13:33.268 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16838::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:33.272 UTC [17764] LOG:  duration: 3.613 ms
2022-11-27 20:13:33.274 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16838::oid
2022-11-27 20:13:33.274 UTC [12445] LOG:  duration: 0.512 ms
2022-11-27 20:13:33.275 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16838::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:33.278 UTC [12445] LOG:  duration: 2.885 ms
2022-11-27 20:13:33.281 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16838
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:33.281 UTC [12445] LOG:  duration: 0.510 ms
2022-11-27 20:13:33.284 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16838::oid
2022-11-27 20:13:33.284 UTC [12445] LOG:  duration: 0.527 ms
2022-11-27 20:13:33.285 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16838::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:33.285 UTC [12445] LOG:  duration: 0.391 ms
2022-11-27 20:13:33.287 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16838::oid
2022-11-27 20:13:33.288 UTC [12445] LOG:  duration: 0.490 ms
2022-11-27 20:13:33.289 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16838
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:33.289 UTC [12445] LOG:  duration: 0.354 ms
2022-11-27 20:13:33.290 UTC [17764] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16848::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16848::oid ORDER BY rel.relname;
2022-11-27 20:13:33.295 UTC [17764] LOG:  duration: 4.976 ms
2022-11-27 20:13:33.298 UTC [17764] LOG:  statement: SELECT COUNT(*)::text FROM public.voyage;
2022-11-27 20:13:33.298 UTC [17764] LOG:  duration: 0.354 ms
2022-11-27 20:13:33.299 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16848::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16848::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.301 UTC [17764] LOG:  duration: 1.614 ms
2022-11-27 20:13:33.302 UTC [17764] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16848::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16848::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.303 UTC [17764] LOG:  duration: 1.464 ms
2022-11-27 20:13:33.304 UTC [17764] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16848::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:13:33.309 UTC [17764] LOG:  duration: 5.229 ms
2022-11-27 20:13:33.311 UTC [17764] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042,1700)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:13:33.312 UTC [17764] LOG:  duration: 0.904 ms
2022-11-27 20:13:33.313 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.314 UTC [17764] LOG:  duration: 0.933 ms
2022-11-27 20:13:33.315 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.316 UTC [17764] LOG:  duration: 0.856 ms
2022-11-27 20:13:33.316 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.317 UTC [17764] LOG:  duration: 0.836 ms
2022-11-27 20:13:33.318 UTC [17764] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:13:33.319 UTC [17764] LOG:  duration: 0.866 ms
2022-11-27 20:13:33.320 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16848::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:13:33.322 UTC [17764] LOG:  duration: 2.366 ms
2022-11-27 20:13:33.323 UTC [17764] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16853 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:13:33.323 UTC [17764] LOG:  duration: 0.201 ms
2022-11-27 20:13:33.324 UTC [17764] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16853::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:13:33.325 UTC [17764] LOG:  duration: 0.536 ms
2022-11-27 20:13:33.326 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16848::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:13:33.328 UTC [17764] LOG:  duration: 2.580 ms
2022-11-27 20:13:33.329 UTC [17764] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16848::oid
	ORDER BY conname
2022-11-27 20:13:33.330 UTC [17764] LOG:  duration: 1.131 ms
2022-11-27 20:13:33.331 UTC [17764] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16848::oid
	
2022-11-27 20:13:33.332 UTC [17764] LOG:  duration: 0.595 ms
2022-11-27 20:13:33.333 UTC [17764] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16848::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:13:33.337 UTC [17764] LOG:  duration: 3.874 ms
2022-11-27 20:13:33.339 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16848::oid
2022-11-27 20:13:33.339 UTC [12445] LOG:  duration: 0.521 ms
2022-11-27 20:13:33.340 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16848::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:13:33.343 UTC [12445] LOG:  duration: 2.844 ms
2022-11-27 20:13:33.345 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16848
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:13:33.346 UTC [12445] LOG:  duration: 0.535 ms
2022-11-27 20:13:33.348 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16848::oid
2022-11-27 20:13:33.348 UTC [12445] LOG:  duration: 0.521 ms
2022-11-27 20:13:33.349 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16848::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:13:33.350 UTC [12445] LOG:  duration: 0.417 ms
2022-11-27 20:13:33.352 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16848::oid
2022-11-27 20:13:33.352 UTC [12445] LOG:  duration: 0.506 ms
2022-11-27 20:13:33.353 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16848
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:13:33.353 UTC [12445] LOG:  duration: 0.366 ms
2022-11-27 20:14:15.338 UTC [12445] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	            nspname NOT LIKE 'pg!_%' escape '!' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2022-11-27 20:14:15.339 UTC [12445] LOG:  duration: 1.519 ms
2022-11-27 20:14:17.731 UTC [12445] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 16426::OID;
2022-11-27 20:14:17.732 UTC [12445] LOG:  duration: 1.091 ms
2022-11-27 20:14:28.891 UTC [12445] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 16426;
2022-11-27 20:14:28.891 UTC [12445] LOG:  duration: 0.428 ms
2022-11-27 20:14:28.932 UTC [12445] LOG:  statement: DROP SCHEMA IF EXISTS ds ;
2022-11-27 20:14:28.939 UTC [12445] ERROR:  cannot drop schema ds because other objects depend on it
2022-11-27 20:14:28.939 UTC [12445] DETAIL:  table ds.pays depends on schema ds
	table ds.ville depends on schema ds
	table ds.voyage depends on schema ds
	table ds.etape depends on schema ds
	table ds.client depends on schema ds
	table ds.reservation depends on schema ds
	table ds.depart depends on schema ds
2022-11-27 20:14:28.939 UTC [12445] HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2022-11-27 20:14:28.939 UTC [12445] STATEMENT:  DROP SCHEMA IF EXISTS ds ;
2022-11-27 20:14:38.122 UTC [17862] LOG:  connection received: host=::1 port=32932
2022-11-27 20:14:38.123 UTC [17862] LOG:  connection authorized: user=postgres database=postgres application_name=pgAdmin 4 - CONN:967442
2022-11-27 20:14:38.125 UTC [17862] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='UNICODE';
2022-11-27 20:14:38.126 UTC [17862] LOG:  duration: 1.454 ms
2022-11-27 20:14:38.126 UTC [17862] LOG:  statement: SELECT version()
2022-11-27 20:14:38.127 UTC [17862] LOG:  duration: 0.217 ms
2022-11-27 20:14:38.127 UTC [17862] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2022-11-27 20:14:38.127 UTC [17862] LOG:  duration: 0.519 ms
2022-11-27 20:14:38.128 UTC [17862] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2022-11-27 20:14:38.128 UTC [17862] LOG:  duration: 0.467 ms
2022-11-27 20:14:38.128 UTC [17862] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2022-11-27 20:14:38.130 UTC [17862] LOG:  duration: 1.812 ms
2022-11-27 20:14:44.321 UTC [17862] LOG:  statement: drop schema ds cascade;
2022-11-27 20:14:44.344 UTC [17862] LOG:  duration: 23.045 ms
2022-11-27 20:14:49.787 UTC [12445] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	            nspname NOT LIKE 'pg!_%' escape '!' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2022-11-27 20:14:49.788 UTC [12445] LOG:  duration: 1.274 ms
2022-11-27 20:14:58.839 UTC [17902] LOG:  connection received: host=::1 port=41886
2022-11-27 20:14:58.840 UTC [17902] LOG:  connection authorized: user=postgres database=postgres application_name=pgAdmin 4 - CONN:7690828
2022-11-27 20:14:58.841 UTC [17902] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='UNICODE';
2022-11-27 20:14:58.842 UTC [17902] LOG:  duration: 1.321 ms
2022-11-27 20:14:58.843 UTC [17902] LOG:  statement: SELECT version()
2022-11-27 20:14:58.843 UTC [17902] LOG:  duration: 0.137 ms
2022-11-27 20:14:58.843 UTC [17902] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2022-11-27 20:14:58.844 UTC [17902] LOG:  duration: 0.487 ms
2022-11-27 20:14:58.844 UTC [17902] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2022-11-27 20:14:58.844 UTC [17902] LOG:  duration: 0.402 ms
2022-11-27 20:14:58.845 UTC [17902] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2022-11-27 20:14:58.846 UTC [17902] LOG:  duration: 1.489 ms
2022-11-27 20:14:59.081 UTC [17902] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2022-11-27 20:14:59.088 UTC [17902] LOG:  duration: 7.415 ms
2022-11-27 20:14:59.094 UTC [17902] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	            nspname NOT LIKE 'pg!_%' escape '!' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2022-11-27 20:14:59.095 UTC [17902] LOG:  duration: 1.028 ms
2022-11-27 20:14:59.192 UTC [17902] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	            nspname NOT LIKE 'pg!_%' escape '!' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2022-11-27 20:14:59.193 UTC [17902] LOG:  duration: 1.030 ms
2022-11-27 20:14:59.194 UTC [17902] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited
	FROM pg_catalog.pg_class rel
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	    AND NOT rel.relispartition
	        AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rel.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY rel.relname;
2022-11-27 20:14:59.202 UTC [17902] LOG:  duration: 7.777 ms
2022-11-27 20:14:59.204 UTC [17902] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16870::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16870::oid ORDER BY rel.relname;
2022-11-27 20:14:59.215 UTC [17902] LOG:  duration: 12.036 ms
2022-11-27 20:14:59.219 UTC [17902] LOG:  statement: SELECT COUNT(*)::text FROM public.client;
2022-11-27 20:14:59.219 UTC [17902] LOG:  duration: 0.457 ms
2022-11-27 20:14:59.220 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16870::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16870::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.222 UTC [17902] LOG:  duration: 2.508 ms
2022-11-27 20:14:59.223 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16870::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16870::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.225 UTC [17902] LOG:  duration: 1.489 ms
2022-11-27 20:14:59.226 UTC [17902] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16870::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:14:59.233 UTC [17902] LOG:  duration: 7.132 ms
2022-11-27 20:14:59.236 UTC [17902] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:14:59.237 UTC [17902] LOG:  duration: 1.225 ms
2022-11-27 20:14:59.238 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.239 UTC [17902] LOG:  duration: 0.913 ms
2022-11-27 20:14:59.240 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.241 UTC [17902] LOG:  duration: 0.825 ms
2022-11-27 20:14:59.242 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.243 UTC [17902] LOG:  duration: 1.415 ms
2022-11-27 20:14:59.244 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.245 UTC [17902] LOG:  duration: 0.803 ms
2022-11-27 20:14:59.246 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.246 UTC [17902] LOG:  duration: 0.788 ms
2022-11-27 20:14:59.247 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16870::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.248 UTC [17902] LOG:  duration: 0.785 ms
2022-11-27 20:14:59.249 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16870::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:14:59.251 UTC [17902] LOG:  duration: 2.521 ms
2022-11-27 20:14:59.252 UTC [17902] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16873 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:14:59.253 UTC [17902] LOG:  duration: 0.232 ms
2022-11-27 20:14:59.254 UTC [17902] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16873::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:14:59.254 UTC [17902] LOG:  duration: 0.615 ms
2022-11-27 20:14:59.255 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16870::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:14:59.258 UTC [17902] LOG:  duration: 2.700 ms
2022-11-27 20:14:59.259 UTC [17902] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16870::oid
	ORDER BY conname
2022-11-27 20:14:59.260 UTC [17902] LOG:  duration: 1.494 ms
2022-11-27 20:14:59.261 UTC [17902] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16870::oid
	    AND a1.attnum=6
	    AND a2.attrelid=16833::oid
	    AND a2.attnum=1
	
2022-11-27 20:14:59.262 UTC [17902] LOG:  duration: 0.330 ms
2022-11-27 20:14:59.263 UTC [17902] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16833::oid
2022-11-27 20:14:59.263 UTC [17902] LOG:  duration: 0.434 ms
2022-11-27 20:14:59.264 UTC [17902] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16870::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16870::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16870::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16870::oid
	   AND conname IS NULL
2022-11-27 20:14:59.267 UTC [17902] LOG:  duration: 3.459 ms
2022-11-27 20:14:59.268 UTC [17902] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16873 , 1 , true) AS column
	
2022-11-27 20:14:59.268 UTC [17902] LOG:  duration: 0.141 ms
2022-11-27 20:14:59.269 UTC [17902] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16870::oid
	
2022-11-27 20:14:59.269 UTC [17902] LOG:  duration: 0.594 ms
2022-11-27 20:14:59.270 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16870::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:14:59.275 UTC [17902] LOG:  duration: 4.279 ms
2022-11-27 20:14:59.278 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16870::oid
2022-11-27 20:14:59.278 UTC [12445] LOG:  duration: 0.324 ms
2022-11-27 20:14:59.279 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16870::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:14:59.282 UTC [12445] LOG:  duration: 3.148 ms
2022-11-27 20:14:59.285 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16870
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:14:59.285 UTC [12445] LOG:  duration: 0.310 ms
2022-11-27 20:14:59.287 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16870::oid
2022-11-27 20:14:59.287 UTC [12445] LOG:  duration: 0.398 ms
2022-11-27 20:14:59.288 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16870::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:14:59.288 UTC [12445] LOG:  duration: 0.403 ms
2022-11-27 20:14:59.290 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16870::oid
2022-11-27 20:14:59.291 UTC [12445] LOG:  duration: 0.489 ms
2022-11-27 20:14:59.292 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16870
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:14:59.292 UTC [12445] LOG:  duration: 0.302 ms
2022-11-27 20:14:59.293 UTC [17902] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16895::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16895::oid ORDER BY rel.relname;
2022-11-27 20:14:59.298 UTC [17902] LOG:  duration: 5.786 ms
2022-11-27 20:14:59.302 UTC [17902] LOG:  statement: SELECT COUNT(*)::text FROM public.depart;
2022-11-27 20:14:59.303 UTC [17902] LOG:  duration: 0.464 ms
2022-11-27 20:14:59.304 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16895::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16895::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.305 UTC [17902] LOG:  duration: 2.014 ms
2022-11-27 20:14:59.307 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16895::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16895::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.308 UTC [17902] LOG:  duration: 1.512 ms
2022-11-27 20:14:59.310 UTC [17902] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16895::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:14:59.315 UTC [17902] LOG:  duration: 5.253 ms
2022-11-27 20:14:59.316 UTC [17902] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1082)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1082)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:14:59.317 UTC [17902] LOG:  duration: 0.761 ms
2022-11-27 20:14:59.318 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.319 UTC [17902] LOG:  duration: 0.807 ms
2022-11-27 20:14:59.320 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.320 UTC [17902] LOG:  duration: 0.891 ms
2022-11-27 20:14:59.321 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16895::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.322 UTC [17902] LOG:  duration: 0.961 ms
2022-11-27 20:14:59.323 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16895::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:14:59.326 UTC [17902] LOG:  duration: 2.520 ms
2022-11-27 20:14:59.327 UTC [17902] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16898 , 1 , true) AS column, 0 AS dummy
	UNION SELECT  pg_catalog.pg_get_indexdef(16898, 2, true) AS column, 1 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:14:59.327 UTC [17902] LOG:  duration: 0.357 ms
2022-11-27 20:14:59.328 UTC [17902] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16898::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:14:59.328 UTC [17902] LOG:  duration: 0.487 ms
2022-11-27 20:14:59.329 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16895::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:14:59.331 UTC [17902] LOG:  duration: 2.294 ms
2022-11-27 20:14:59.332 UTC [17902] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16895::oid
	ORDER BY conname
2022-11-27 20:14:59.333 UTC [17902] LOG:  duration: 1.029 ms
2022-11-27 20:14:59.334 UTC [17902] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16895::oid
	    AND a1.attnum=1
	    AND a2.attrelid=16848::oid
	    AND a2.attnum=1
	
2022-11-27 20:14:59.335 UTC [17902] LOG:  duration: 0.283 ms
2022-11-27 20:14:59.335 UTC [17902] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16848::oid
2022-11-27 20:14:59.336 UTC [17902] LOG:  duration: 0.318 ms
2022-11-27 20:14:59.337 UTC [17902] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16895::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16895::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16895::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16895::oid
	   AND conname IS NULL
2022-11-27 20:14:59.341 UTC [17902] LOG:  duration: 4.783 ms
2022-11-27 20:14:59.343 UTC [17902] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16898 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16898, 2, true) AS column
	
2022-11-27 20:14:59.343 UTC [17902] LOG:  duration: 0.230 ms
2022-11-27 20:14:59.344 UTC [17902] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16895::oid
	
2022-11-27 20:14:59.344 UTC [17902] LOG:  duration: 0.550 ms
2022-11-27 20:14:59.345 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16895::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:14:59.349 UTC [17902] LOG:  duration: 3.530 ms
2022-11-27 20:14:59.352 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16895::oid
2022-11-27 20:14:59.352 UTC [12445] LOG:  duration: 0.466 ms
2022-11-27 20:14:59.354 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16895::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:14:59.358 UTC [12445] LOG:  duration: 4.029 ms
2022-11-27 20:14:59.360 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16895
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:14:59.360 UTC [12445] LOG:  duration: 0.356 ms
2022-11-27 20:14:59.362 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16895::oid
2022-11-27 20:14:59.362 UTC [12445] LOG:  duration: 0.370 ms
2022-11-27 20:14:59.363 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16895::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:14:59.364 UTC [12445] LOG:  duration: 0.463 ms
2022-11-27 20:14:59.365 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16895::oid
2022-11-27 20:14:59.366 UTC [12445] LOG:  duration: 0.346 ms
2022-11-27 20:14:59.366 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16895
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:14:59.367 UTC [12445] LOG:  duration: 0.301 ms
2022-11-27 20:14:59.368 UTC [17902] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16855::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16855::oid ORDER BY rel.relname;
2022-11-27 20:14:59.375 UTC [17902] LOG:  duration: 7.784 ms
2022-11-27 20:14:59.378 UTC [17902] LOG:  statement: SELECT COUNT(*)::text FROM public.etape;
2022-11-27 20:14:59.379 UTC [17902] LOG:  duration: 0.401 ms
2022-11-27 20:14:59.380 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16855::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16855::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.381 UTC [17902] LOG:  duration: 1.580 ms
2022-11-27 20:14:59.382 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16855::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16855::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.383 UTC [17902] LOG:  duration: 1.435 ms
2022-11-27 20:14:59.385 UTC [17902] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16855::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:14:59.391 UTC [17902] LOG:  duration: 6.647 ms
2022-11-27 20:14:59.393 UTC [17902] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:14:59.394 UTC [17902] LOG:  duration: 0.768 ms
2022-11-27 20:14:59.395 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.395 UTC [17902] LOG:  duration: 0.760 ms
2022-11-27 20:14:59.396 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.397 UTC [17902] LOG:  duration: 0.709 ms
2022-11-27 20:14:59.398 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.398 UTC [17902] LOG:  duration: 0.797 ms
2022-11-27 20:14:59.399 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16855::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.400 UTC [17902] LOG:  duration: 0.809 ms
2022-11-27 20:14:59.401 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16855::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:14:59.403 UTC [17902] LOG:  duration: 2.584 ms
2022-11-27 20:14:59.405 UTC [17902] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16858 , 1 , true) AS column, 0 AS dummy
	UNION SELECT  pg_catalog.pg_get_indexdef(16858, 2, true) AS column, 1 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:14:59.405 UTC [17902] LOG:  duration: 0.359 ms
2022-11-27 20:14:59.406 UTC [17902] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16858::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:14:59.407 UTC [17902] LOG:  duration: 0.573 ms
2022-11-27 20:14:59.408 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16855::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:14:59.410 UTC [17902] LOG:  duration: 2.538 ms
2022-11-27 20:14:59.411 UTC [17902] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16855::oid
	ORDER BY conname
2022-11-27 20:14:59.412 UTC [17902] LOG:  duration: 1.029 ms
2022-11-27 20:14:59.413 UTC [17902] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16855::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16838::oid
	    AND a2.attnum=1
	
2022-11-27 20:14:59.413 UTC [17902] LOG:  duration: 0.259 ms
2022-11-27 20:14:59.414 UTC [17902] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16838::oid
2022-11-27 20:14:59.414 UTC [17902] LOG:  duration: 0.297 ms
2022-11-27 20:14:59.415 UTC [17902] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	   AND conname IS NULL
2022-11-27 20:14:59.418 UTC [17902] LOG:  duration: 3.014 ms
2022-11-27 20:14:59.419 UTC [17902] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16858 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16858, 2, true) AS column
	
2022-11-27 20:14:59.419 UTC [17902] LOG:  duration: 0.194 ms
2022-11-27 20:14:59.420 UTC [17902] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16855::oid
	    AND a1.attnum=1
	    AND a2.attrelid=16848::oid
	    AND a2.attnum=1
	
2022-11-27 20:14:59.420 UTC [17902] LOG:  duration: 0.307 ms
2022-11-27 20:14:59.421 UTC [17902] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16848::oid
2022-11-27 20:14:59.422 UTC [17902] LOG:  duration: 0.442 ms
2022-11-27 20:14:59.423 UTC [17902] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16855::oid
	   AND conname IS NULL
2022-11-27 20:14:59.426 UTC [17902] LOG:  duration: 3.419 ms
2022-11-27 20:14:59.427 UTC [17902] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16858 , 1 , true) AS column
	UNION SELECT  pg_catalog.pg_get_indexdef(16858, 2, true) AS column
	
2022-11-27 20:14:59.427 UTC [17902] LOG:  duration: 0.189 ms
2022-11-27 20:14:59.428 UTC [17902] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16855::oid
	
2022-11-27 20:14:59.428 UTC [17902] LOG:  duration: 0.537 ms
2022-11-27 20:14:59.429 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16855::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:14:59.433 UTC [17902] LOG:  duration: 3.685 ms
2022-11-27 20:14:59.435 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16855::oid
2022-11-27 20:14:59.435 UTC [12445] LOG:  duration: 0.475 ms
2022-11-27 20:14:59.437 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16855::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:14:59.441 UTC [12445] LOG:  duration: 3.875 ms
2022-11-27 20:14:59.443 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16855
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:14:59.444 UTC [12445] LOG:  duration: 0.503 ms
2022-11-27 20:14:59.446 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16855::oid
2022-11-27 20:14:59.446 UTC [12445] LOG:  duration: 0.312 ms
2022-11-27 20:14:59.447 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16855::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:14:59.447 UTC [12445] LOG:  duration: 0.406 ms
2022-11-27 20:14:59.449 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16855::oid
2022-11-27 20:14:59.450 UTC [12445] LOG:  duration: 0.313 ms
2022-11-27 20:14:59.451 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16855
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:14:59.451 UTC [12445] LOG:  duration: 0.369 ms
2022-11-27 20:14:59.452 UTC [17902] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16833::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16833::oid ORDER BY rel.relname;
2022-11-27 20:14:59.459 UTC [17902] LOG:  duration: 7.434 ms
2022-11-27 20:14:59.462 UTC [17902] LOG:  statement: SELECT COUNT(*)::text FROM public.pays;
2022-11-27 20:14:59.462 UTC [17902] LOG:  duration: 0.371 ms
2022-11-27 20:14:59.463 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16833::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16833::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.464 UTC [17902] LOG:  duration: 1.430 ms
2022-11-27 20:14:59.465 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16833::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16833::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.467 UTC [17902] LOG:  duration: 1.591 ms
2022-11-27 20:14:59.468 UTC [17902] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16833::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:14:59.473 UTC [17902] LOG:  duration: 5.877 ms
2022-11-27 20:14:59.475 UTC [17902] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1042,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1042,1043)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:14:59.476 UTC [17902] LOG:  duration: 0.757 ms
2022-11-27 20:14:59.477 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16833::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16833::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.478 UTC [17902] LOG:  duration: 0.789 ms
2022-11-27 20:14:59.478 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16833::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16833::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.479 UTC [17902] LOG:  duration: 0.761 ms
2022-11-27 20:14:59.480 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16833::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:14:59.482 UTC [17902] LOG:  duration: 2.496 ms
2022-11-27 20:14:59.483 UTC [17902] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16836 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:14:59.483 UTC [17902] LOG:  duration: 0.208 ms
2022-11-27 20:14:59.484 UTC [17902] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16836::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:14:59.485 UTC [17902] LOG:  duration: 0.533 ms
2022-11-27 20:14:59.486 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16833::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:14:59.488 UTC [17902] LOG:  duration: 2.773 ms
2022-11-27 20:14:59.489 UTC [17902] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16833::oid
	ORDER BY conname
2022-11-27 20:14:59.490 UTC [17902] LOG:  duration: 1.027 ms
2022-11-27 20:14:59.491 UTC [17902] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16833::oid
	
2022-11-27 20:14:59.492 UTC [17902] LOG:  duration: 0.587 ms
2022-11-27 20:14:59.493 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16833::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:14:59.496 UTC [17902] LOG:  duration: 3.503 ms
2022-11-27 20:14:59.499 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16833::oid
2022-11-27 20:14:59.499 UTC [12445] LOG:  duration: 0.477 ms
2022-11-27 20:14:59.501 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16833::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:14:59.504 UTC [12445] LOG:  duration: 3.225 ms
2022-11-27 20:14:59.507 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16833
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:14:59.507 UTC [12445] LOG:  duration: 0.330 ms
2022-11-27 20:14:59.509 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16833::oid
2022-11-27 20:14:59.509 UTC [12445] LOG:  duration: 0.302 ms
2022-11-27 20:14:59.510 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16833::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:14:59.510 UTC [12445] LOG:  duration: 0.419 ms
2022-11-27 20:14:59.512 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16833::oid
2022-11-27 20:14:59.513 UTC [12445] LOG:  duration: 0.463 ms
2022-11-27 20:14:59.514 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16833
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:14:59.514 UTC [12445] LOG:  duration: 0.310 ms
2022-11-27 20:14:59.515 UTC [17902] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16880::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16880::oid ORDER BY rel.relname;
2022-11-27 20:14:59.521 UTC [17902] LOG:  duration: 5.970 ms
2022-11-27 20:14:59.524 UTC [17902] LOG:  statement: SELECT COUNT(*)::text FROM public.reservation;
2022-11-27 20:14:59.524 UTC [17902] LOG:  duration: 0.363 ms
2022-11-27 20:14:59.525 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16880::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16880::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.526 UTC [17902] LOG:  duration: 1.568 ms
2022-11-27 20:14:59.527 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16880::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16880::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.528 UTC [17902] LOG:  duration: 1.417 ms
2022-11-27 20:14:59.530 UTC [17902] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16880::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:14:59.534 UTC [17902] LOG:  duration: 5.069 ms
2022-11-27 20:14:59.536 UTC [17902] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1082)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1082)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:14:59.537 UTC [17902] LOG:  duration: 0.807 ms
2022-11-27 20:14:59.538 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.539 UTC [17902] LOG:  duration: 0.865 ms
2022-11-27 20:14:59.540 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.541 UTC [17902] LOG:  duration: 0.861 ms
2022-11-27 20:14:59.542 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.543 UTC [17902] LOG:  duration: 0.847 ms
2022-11-27 20:14:59.543 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.544 UTC [17902] LOG:  duration: 0.819 ms
2022-11-27 20:14:59.545 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.546 UTC [17902] LOG:  duration: 0.827 ms
2022-11-27 20:14:59.546 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.547 UTC [17902] LOG:  duration: 0.826 ms
2022-11-27 20:14:59.548 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 7::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16880::oid
	        AND att.attnum = 7::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.549 UTC [17902] LOG:  duration: 0.835 ms
2022-11-27 20:14:59.550 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16880::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:14:59.552 UTC [17902] LOG:  duration: 2.463 ms
2022-11-27 20:14:59.553 UTC [17902] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16883 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:14:59.553 UTC [17902] LOG:  duration: 0.240 ms
2022-11-27 20:14:59.554 UTC [17902] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16883::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:14:59.554 UTC [17902] LOG:  duration: 0.637 ms
2022-11-27 20:14:59.555 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16880::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:14:59.558 UTC [17902] LOG:  duration: 2.424 ms
2022-11-27 20:14:59.559 UTC [17902] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16880::oid
	ORDER BY conname
2022-11-27 20:14:59.560 UTC [17902] LOG:  duration: 1.020 ms
2022-11-27 20:14:59.561 UTC [17902] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16880::oid
	    AND a1.attnum=7
	    AND a2.attrelid=16870::oid
	    AND a2.attnum=1
	
2022-11-27 20:14:59.561 UTC [17902] LOG:  duration: 0.273 ms
2022-11-27 20:14:59.561 UTC [17902] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16870::oid
2022-11-27 20:14:59.562 UTC [17902] LOG:  duration: 0.286 ms
2022-11-27 20:14:59.562 UTC [17902] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	   AND conname IS NULL
2022-11-27 20:14:59.565 UTC [17902] LOG:  duration: 3.008 ms
2022-11-27 20:14:59.566 UTC [17902] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16883 , 1 , true) AS column
	
2022-11-27 20:14:59.566 UTC [17902] LOG:  duration: 0.194 ms
2022-11-27 20:14:59.567 UTC [17902] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16880::oid
	    AND a1.attnum=4
	    AND a2.attrelid=16848::oid
	    AND a2.attnum=1
	
2022-11-27 20:14:59.567 UTC [17902] LOG:  duration: 0.210 ms
2022-11-27 20:14:59.568 UTC [17902] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16848::oid
2022-11-27 20:14:59.568 UTC [17902] LOG:  duration: 0.224 ms
2022-11-27 20:14:59.568 UTC [17902] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16880::oid
	   AND conname IS NULL
2022-11-27 20:14:59.572 UTC [17902] LOG:  duration: 3.287 ms
2022-11-27 20:14:59.572 UTC [17902] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16883 , 1 , true) AS column
	
2022-11-27 20:14:59.573 UTC [17902] LOG:  duration: 0.153 ms
2022-11-27 20:14:59.573 UTC [17902] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16880::oid
	
2022-11-27 20:14:59.574 UTC [17902] LOG:  duration: 0.558 ms
2022-11-27 20:14:59.575 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16880::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:14:59.579 UTC [17902] LOG:  duration: 4.060 ms
2022-11-27 20:14:59.582 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16880::oid
2022-11-27 20:14:59.582 UTC [12445] LOG:  duration: 0.448 ms
2022-11-27 20:14:59.583 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16880::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:14:59.586 UTC [12445] LOG:  duration: 2.872 ms
2022-11-27 20:14:59.589 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16880
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:14:59.589 UTC [12445] LOG:  duration: 0.387 ms
2022-11-27 20:14:59.591 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16880::oid
2022-11-27 20:14:59.592 UTC [12445] LOG:  duration: 0.467 ms
2022-11-27 20:14:59.592 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16880::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:14:59.593 UTC [12445] LOG:  duration: 0.338 ms
2022-11-27 20:14:59.595 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16880::oid
2022-11-27 20:14:59.595 UTC [12445] LOG:  duration: 0.446 ms
2022-11-27 20:14:59.596 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16880
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:14:59.596 UTC [12445] LOG:  duration: 0.295 ms
2022-11-27 20:14:59.598 UTC [17902] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16838::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16838::oid ORDER BY rel.relname;
2022-11-27 20:14:59.604 UTC [17902] LOG:  duration: 6.592 ms
2022-11-27 20:14:59.607 UTC [17902] LOG:  statement: SELECT COUNT(*)::text FROM public.ville;
2022-11-27 20:14:59.608 UTC [17902] LOG:  duration: 0.400 ms
2022-11-27 20:14:59.609 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16838::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16838::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.610 UTC [17902] LOG:  duration: 1.477 ms
2022-11-27 20:14:59.611 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16838::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16838::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.612 UTC [17902] LOG:  duration: 1.426 ms
2022-11-27 20:14:59.613 UTC [17902] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16838::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:14:59.618 UTC [17902] LOG:  duration: 5.168 ms
2022-11-27 20:14:59.620 UTC [17902] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:14:59.621 UTC [17902] LOG:  duration: 0.898 ms
2022-11-27 20:14:59.622 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.623 UTC [17902] LOG:  duration: 0.865 ms
2022-11-27 20:14:59.624 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.624 UTC [17902] LOG:  duration: 0.854 ms
2022-11-27 20:14:59.625 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16838::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.626 UTC [17902] LOG:  duration: 0.826 ms
2022-11-27 20:14:59.627 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16838::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:14:59.629 UTC [17902] LOG:  duration: 2.424 ms
2022-11-27 20:14:59.630 UTC [17902] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16841 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:14:59.630 UTC [17902] LOG:  duration: 0.256 ms
2022-11-27 20:14:59.631 UTC [17902] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16841::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:14:59.632 UTC [17902] LOG:  duration: 0.587 ms
2022-11-27 20:14:59.632 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16838::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:14:59.635 UTC [17902] LOG:  duration: 2.368 ms
2022-11-27 20:14:59.636 UTC [17902] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16838::oid
	ORDER BY conname
2022-11-27 20:14:59.636 UTC [17902] LOG:  duration: 1.069 ms
2022-11-27 20:14:59.638 UTC [17902] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16838::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16833::oid
	    AND a2.attnum=1
	
2022-11-27 20:14:59.638 UTC [17902] LOG:  duration: 0.413 ms
2022-11-27 20:14:59.639 UTC [17902] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16833::oid
2022-11-27 20:14:59.639 UTC [17902] LOG:  duration: 0.300 ms
2022-11-27 20:14:59.640 UTC [17902] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16838::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16838::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16838::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16838::oid
	   AND conname IS NULL
2022-11-27 20:14:59.643 UTC [17902] LOG:  duration: 3.110 ms
2022-11-27 20:14:59.644 UTC [17902] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16841 , 1 , true) AS column
	
2022-11-27 20:14:59.644 UTC [17902] LOG:  duration: 0.131 ms
2022-11-27 20:14:59.645 UTC [17902] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16838::oid
	
2022-11-27 20:14:59.645 UTC [17902] LOG:  duration: 0.535 ms
2022-11-27 20:14:59.646 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16838::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:14:59.650 UTC [17902] LOG:  duration: 3.716 ms
2022-11-27 20:14:59.652 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16838::oid
2022-11-27 20:14:59.652 UTC [12445] LOG:  duration: 0.469 ms
2022-11-27 20:14:59.654 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16838::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:14:59.657 UTC [12445] LOG:  duration: 3.225 ms
2022-11-27 20:14:59.659 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16838
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:14:59.660 UTC [12445] LOG:  duration: 0.323 ms
2022-11-27 20:14:59.661 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16838::oid
2022-11-27 20:14:59.662 UTC [12445] LOG:  duration: 0.329 ms
2022-11-27 20:14:59.663 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16838::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:14:59.663 UTC [12445] LOG:  duration: 0.304 ms
2022-11-27 20:14:59.665 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16838::oid
2022-11-27 20:14:59.665 UTC [12445] LOG:  duration: 0.303 ms
2022-11-27 20:14:59.666 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16838
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:14:59.666 UTC [12445] LOG:  duration: 0.283 ms
2022-11-27 20:14:59.668 UTC [17902] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 14767::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 16832::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 16832::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16848::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16848::oid ORDER BY rel.relname;
2022-11-27 20:14:59.674 UTC [17902] LOG:  duration: 6.589 ms
2022-11-27 20:14:59.677 UTC [17902] LOG:  statement: SELECT COUNT(*)::text FROM public.voyage;
2022-11-27 20:14:59.677 UTC [17902] LOG:  duration: 0.288 ms
2022-11-27 20:14:59.678 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16848::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16848::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.679 UTC [17902] LOG:  duration: 1.420 ms
2022-11-27 20:14:59.680 UTC [17902] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16848::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 16832::oid
	            AND rel.oid = 16848::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.681 UTC [17902] LOG:  duration: 1.201 ms
2022-11-27 20:14:59.683 UTC [17902] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16848::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2022-11-27 20:14:59.688 UTC [17902] LOG:  duration: 5.319 ms
2022-11-27 20:14:59.690 UTC [17902] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1042,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1042,1700)
	) t
	GROUP BY t.main_oid;
2022-11-27 20:14:59.691 UTC [17902] LOG:  duration: 0.981 ms
2022-11-27 20:14:59.692 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.693 UTC [17902] LOG:  duration: 0.839 ms
2022-11-27 20:14:59.694 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.695 UTC [17902] LOG:  duration: 0.768 ms
2022-11-27 20:14:59.695 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.696 UTC [17902] LOG:  duration: 0.755 ms
2022-11-27 20:14:59.697 UTC [17902] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16848::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2022-11-27 20:14:59.698 UTC [17902] LOG:  duration: 0.749 ms
2022-11-27 20:14:59.699 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16848::oid
	AND contype='p'
	ORDER BY cls.relname
2022-11-27 20:14:59.701 UTC [17902] LOG:  duration: 2.426 ms
2022-11-27 20:14:59.702 UTC [17902] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16853 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2022-11-27 20:14:59.703 UTC [17902] LOG:  duration: 0.212 ms
2022-11-27 20:14:59.703 UTC [17902] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16853::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2022-11-27 20:14:59.704 UTC [17902] LOG:  duration: 0.618 ms
2022-11-27 20:14:59.705 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16848::oid
	AND contype='u'
	ORDER BY cls.relname
2022-11-27 20:14:59.707 UTC [17902] LOG:  duration: 2.478 ms
2022-11-27 20:14:59.709 UTC [17902] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16848::oid
	ORDER BY conname
2022-11-27 20:14:59.710 UTC [17902] LOG:  duration: 0.970 ms
2022-11-27 20:14:59.711 UTC [17902] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16848::oid
	
2022-11-27 20:14:59.711 UTC [17902] LOG:  duration: 0.527 ms
2022-11-27 20:14:59.712 UTC [17902] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 14767::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16848::oid
	AND contype='x'
	ORDER BY cls.relname
2022-11-27 20:14:59.716 UTC [17902] LOG:  duration: 3.618 ms
2022-11-27 20:14:59.718 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16848::oid
2022-11-27 20:14:59.719 UTC [12445] LOG:  duration: 0.346 ms
2022-11-27 20:14:59.720 UTC [12445] LOG:  statement: SELECT DISTINCT ON(cls.relname) cls.oid, cls.relname as name,
	(SELECT (CASE WHEN count(i.inhrelid) > 0 THEN true ELSE false END) FROM pg_inherits i WHERE i.inhrelid = cls.oid) as is_inherited,
	CASE WHEN contype IN ('p', 'u', 'x') THEN desp.description ELSE des.description END AS description
	FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    JOIN pg_catalog.pg_class tab ON tab.oid=indrelid
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	    JOIN pg_catalog.pg_namespace n ON n.oid=tab.relnamespace
	    JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16848::OID
	    AND conname is NULL
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = cls.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY cls.relname
2022-11-27 20:14:59.723 UTC [12445] LOG:  duration: 3.044 ms
2022-11-27 20:14:59.725 UTC [12445] LOG:  statement: SELECT
	    rw.oid AS oid,
	    rw.rulename AS name,
	    CASE WHEN rw.ev_enabled != 'D' THEN True ELSE False END AS enabled,
	    rw.ev_enabled AS is_enable_rule
	
	FROM
	    pg_catalog.pg_rewrite rw
	WHERE
	    rw.ev_class = 16848
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = rw.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    rw.rulename
2022-11-27 20:14:59.725 UTC [12445] LOG:  duration: 0.341 ms
2022-11-27 20:14:59.727 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16848::oid
2022-11-27 20:14:59.727 UTC [12445] LOG:  duration: 0.313 ms
2022-11-27 20:14:59.728 UTC [12445] LOG:  statement: SELECT t.oid, t.tgname as name, t.tgenabled AS is_enable_trigger
	FROM pg_catalog.pg_trigger t
	    WHERE NOT tgisinternal
	    AND tgrelid = 16848::OID
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = t.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	    ORDER BY tgname;
2022-11-27 20:14:59.728 UTC [12445] LOG:  duration: 0.318 ms
2022-11-27 20:14:59.730 UTC [12445] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16848::oid
2022-11-27 20:14:59.731 UTC [12445] LOG:  duration: 0.321 ms
2022-11-27 20:14:59.731 UTC [12445] LOG:  statement: SELECT
	    pl.oid AS oid,
	    pl.polname AS name
	FROM
	    pg_catalog.pg_policy pl
	WHERE
	    pl.polrelid	 = 16848
	    AND CASE WHEN (SELECT COUNT(*) FROM pg_catalog.pg_depend
	        WHERE objid = pl.oid AND deptype = 'e') > 0 THEN FALSE ELSE TRUE END
	ORDER BY
	    pl.polname;
2022-11-27 20:14:59.732 UTC [12445] LOG:  duration: 0.312 ms
2022-11-27 20:22:58.047 UTC [12481] LOG:  disconnection: session time: 1:25:24.088 user=postgres database=postgres host=::1 port=35616
2022-11-27 20:22:58.047 UTC [17862] LOG:  disconnection: session time: 0:08:19.924 user=postgres database=postgres host=::1 port=32932
2022-11-27 20:22:58.047 UTC [17902] LOG:  disconnection: session time: 0:07:59.208 user=postgres database=postgres host=::1 port=41886
2022-11-27 20:22:58.047 UTC [17764] LOG:  disconnection: session time: 0:09:26.909 user=postgres database=postgres host=::1 port=38170
2022-11-27 20:22:58.050 UTC [12445] LOG:  disconnection: session time: 1:25:34.535 user=postgres database=postgres host=::1 port=50114
2022-11-27 20:22:58.722 UTC [11909] LOG:  received smart shutdown request
2022-11-27 20:22:58.725 UTC [11909] LOG:  background worker "logical replication launcher" (PID 11917) exited with exit code 1
2022-11-27 20:22:58.725 UTC [11912] LOG:  shutting down
2022-11-27 20:22:58.745 UTC [11909] LOG:  database system is shut down
